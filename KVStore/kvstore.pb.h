// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvstore.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kvstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kvstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kvstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kvstore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kvstore_2eproto;
class FetchNodeRequest;
struct FetchNodeRequestDefaultTypeInternal;
extern FetchNodeRequestDefaultTypeInternal _FetchNodeRequest_default_instance_;
class FetchNodeResponse;
struct FetchNodeResponseDefaultTypeInternal;
extern FetchNodeResponseDefaultTypeInternal _FetchNodeResponse_default_instance_;
class KVRequest;
struct KVRequestDefaultTypeInternal;
extern KVRequestDefaultTypeInternal _KVRequest_default_instance_;
class KVRequest_KVCPutRequest;
struct KVRequest_KVCPutRequestDefaultTypeInternal;
extern KVRequest_KVCPutRequestDefaultTypeInternal _KVRequest_KVCPutRequest_default_instance_;
class KVRequest_KVDeleteRequest;
struct KVRequest_KVDeleteRequestDefaultTypeInternal;
extern KVRequest_KVDeleteRequestDefaultTypeInternal _KVRequest_KVDeleteRequest_default_instance_;
class KVRequest_KVFiletransferRequest;
struct KVRequest_KVFiletransferRequestDefaultTypeInternal;
extern KVRequest_KVFiletransferRequestDefaultTypeInternal _KVRequest_KVFiletransferRequest_default_instance_;
class KVRequest_KVGetRequest;
struct KVRequest_KVGetRequestDefaultTypeInternal;
extern KVRequest_KVGetRequestDefaultTypeInternal _KVRequest_KVGetRequest_default_instance_;
class KVRequest_KVPutRequest;
struct KVRequest_KVPutRequestDefaultTypeInternal;
extern KVRequest_KVPutRequestDefaultTypeInternal _KVRequest_KVPutRequest_default_instance_;
class KVRequest_KVRecoveryRequest;
struct KVRequest_KVRecoveryRequestDefaultTypeInternal;
extern KVRequest_KVRecoveryRequestDefaultTypeInternal _KVRequest_KVRecoveryRequest_default_instance_;
class KVRequest_KVReplayRequest;
struct KVRequest_KVReplayRequestDefaultTypeInternal;
extern KVRequest_KVReplayRequestDefaultTypeInternal _KVRequest_KVReplayRequest_default_instance_;
class KVRequest_KVScputRequest;
struct KVRequest_KVScputRequestDefaultTypeInternal;
extern KVRequest_KVScputRequestDefaultTypeInternal _KVRequest_KVScputRequest_default_instance_;
class KVRequest_KVSdeleteRequest;
struct KVRequest_KVSdeleteRequestDefaultTypeInternal;
extern KVRequest_KVSdeleteRequestDefaultTypeInternal _KVRequest_KVSdeleteRequest_default_instance_;
class KVRequest_KVSgetRequest;
struct KVRequest_KVSgetRequestDefaultTypeInternal;
extern KVRequest_KVSgetRequestDefaultTypeInternal _KVRequest_KVSgetRequest_default_instance_;
class KVRequest_KVSputRequest;
struct KVRequest_KVSputRequestDefaultTypeInternal;
extern KVRequest_KVSputRequestDefaultTypeInternal _KVRequest_KVSputRequest_default_instance_;
class KVRequest_KVSuspendRequest;
struct KVRequest_KVSuspendRequestDefaultTypeInternal;
extern KVRequest_KVSuspendRequestDefaultTypeInternal _KVRequest_KVSuspendRequest_default_instance_;
class KVResponse;
struct KVResponseDefaultTypeInternal;
extern KVResponseDefaultTypeInternal _KVResponse_default_instance_;
class NotifyRecoveryFinishedRequest;
struct NotifyRecoveryFinishedRequestDefaultTypeInternal;
extern NotifyRecoveryFinishedRequestDefaultTypeInternal _NotifyRecoveryFinishedRequest_default_instance_;
class PollStatusRequest;
struct PollStatusRequestDefaultTypeInternal;
extern PollStatusRequestDefaultTypeInternal _PollStatusRequest_default_instance_;
class PollStatusResponse;
struct PollStatusResponseDefaultTypeInternal;
extern PollStatusResponseDefaultTypeInternal _PollStatusResponse_default_instance_;
class PollStatusResponse_Cluster;
struct PollStatusResponse_ClusterDefaultTypeInternal;
extern PollStatusResponse_ClusterDefaultTypeInternal _PollStatusResponse_Cluster_default_instance_;
class PollStatusResponse_Cluster_Node;
struct PollStatusResponse_Cluster_NodeDefaultTypeInternal;
extern PollStatusResponse_Cluster_NodeDefaultTypeInternal _PollStatusResponse_Cluster_Node_default_instance_;
class ReviveRequest;
struct ReviveRequestDefaultTypeInternal;
extern ReviveRequestDefaultTypeInternal _ReviveRequest_default_instance_;
class SuspendRequest;
struct SuspendRequestDefaultTypeInternal;
extern SuspendRequestDefaultTypeInternal _SuspendRequest_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::FetchNodeRequest* Arena::CreateMaybeMessage<::FetchNodeRequest>(Arena*);
template<> ::FetchNodeResponse* Arena::CreateMaybeMessage<::FetchNodeResponse>(Arena*);
template<> ::KVRequest* Arena::CreateMaybeMessage<::KVRequest>(Arena*);
template<> ::KVRequest_KVCPutRequest* Arena::CreateMaybeMessage<::KVRequest_KVCPutRequest>(Arena*);
template<> ::KVRequest_KVDeleteRequest* Arena::CreateMaybeMessage<::KVRequest_KVDeleteRequest>(Arena*);
template<> ::KVRequest_KVFiletransferRequest* Arena::CreateMaybeMessage<::KVRequest_KVFiletransferRequest>(Arena*);
template<> ::KVRequest_KVGetRequest* Arena::CreateMaybeMessage<::KVRequest_KVGetRequest>(Arena*);
template<> ::KVRequest_KVPutRequest* Arena::CreateMaybeMessage<::KVRequest_KVPutRequest>(Arena*);
template<> ::KVRequest_KVRecoveryRequest* Arena::CreateMaybeMessage<::KVRequest_KVRecoveryRequest>(Arena*);
template<> ::KVRequest_KVReplayRequest* Arena::CreateMaybeMessage<::KVRequest_KVReplayRequest>(Arena*);
template<> ::KVRequest_KVScputRequest* Arena::CreateMaybeMessage<::KVRequest_KVScputRequest>(Arena*);
template<> ::KVRequest_KVSdeleteRequest* Arena::CreateMaybeMessage<::KVRequest_KVSdeleteRequest>(Arena*);
template<> ::KVRequest_KVSgetRequest* Arena::CreateMaybeMessage<::KVRequest_KVSgetRequest>(Arena*);
template<> ::KVRequest_KVSputRequest* Arena::CreateMaybeMessage<::KVRequest_KVSputRequest>(Arena*);
template<> ::KVRequest_KVSuspendRequest* Arena::CreateMaybeMessage<::KVRequest_KVSuspendRequest>(Arena*);
template<> ::KVResponse* Arena::CreateMaybeMessage<::KVResponse>(Arena*);
template<> ::NotifyRecoveryFinishedRequest* Arena::CreateMaybeMessage<::NotifyRecoveryFinishedRequest>(Arena*);
template<> ::PollStatusRequest* Arena::CreateMaybeMessage<::PollStatusRequest>(Arena*);
template<> ::PollStatusResponse* Arena::CreateMaybeMessage<::PollStatusResponse>(Arena*);
template<> ::PollStatusResponse_Cluster* Arena::CreateMaybeMessage<::PollStatusResponse_Cluster>(Arena*);
template<> ::PollStatusResponse_Cluster_Node* Arena::CreateMaybeMessage<::PollStatusResponse_Cluster_Node>(Arena*);
template<> ::ReviveRequest* Arena::CreateMaybeMessage<::ReviveRequest>(Arena*);
template<> ::SuspendRequest* Arena::CreateMaybeMessage<::SuspendRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum KVStatusCode : int {
  SUCCESS = 0,
  FAILURE = 1,
  SUSPENDED = 2,
  RECOVERING = 3,
  KVStatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KVStatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KVStatusCode_IsValid(int value);
constexpr KVStatusCode KVStatusCode_MIN = SUCCESS;
constexpr KVStatusCode KVStatusCode_MAX = RECOVERING;
constexpr int KVStatusCode_ARRAYSIZE = KVStatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KVStatusCode_descriptor();
template<typename T>
inline const std::string& KVStatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KVStatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KVStatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KVStatusCode_descriptor(), enum_t_value);
}
inline bool KVStatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KVStatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KVStatusCode>(
    KVStatusCode_descriptor(), name, value);
}
enum FileType : int {
  CHECKPOINT = 0,
  LOGFILE = 1,
  FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FileType_IsValid(int value);
constexpr FileType FileType_MIN = CHECKPOINT;
constexpr FileType FileType_MAX = LOGFILE;
constexpr int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileType_descriptor();
template<typename T>
inline const std::string& FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileType_descriptor(), enum_t_value);
}
inline bool FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
// ===================================================================

class KVRequest_KVGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVGetRequest) */ {
 public:
  inline KVRequest_KVGetRequest() : KVRequest_KVGetRequest(nullptr) {}
  ~KVRequest_KVGetRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVGetRequest(const KVRequest_KVGetRequest& from);
  KVRequest_KVGetRequest(KVRequest_KVGetRequest&& from) noexcept
    : KVRequest_KVGetRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVGetRequest& operator=(const KVRequest_KVGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVGetRequest& operator=(KVRequest_KVGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVGetRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVGetRequest*>(
               &_KVRequest_KVGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KVRequest_KVGetRequest& a, KVRequest_KVGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVGetRequest& from) {
    KVRequest_KVGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVGetRequest";
  }
  protected:
  explicit KVRequest_KVGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVSgetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVSgetRequest) */ {
 public:
  inline KVRequest_KVSgetRequest() : KVRequest_KVSgetRequest(nullptr) {}
  ~KVRequest_KVSgetRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVSgetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVSgetRequest(const KVRequest_KVSgetRequest& from);
  KVRequest_KVSgetRequest(KVRequest_KVSgetRequest&& from) noexcept
    : KVRequest_KVSgetRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVSgetRequest& operator=(const KVRequest_KVSgetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVSgetRequest& operator=(KVRequest_KVSgetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVSgetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVSgetRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVSgetRequest*>(
               &_KVRequest_KVSgetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KVRequest_KVSgetRequest& a, KVRequest_KVSgetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVSgetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVSgetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVSgetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVSgetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVSgetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVSgetRequest& from) {
    KVRequest_KVSgetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVSgetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVSgetRequest";
  }
  protected:
  explicit KVRequest_KVSgetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVSgetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVPutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVPutRequest) */ {
 public:
  inline KVRequest_KVPutRequest() : KVRequest_KVPutRequest(nullptr) {}
  ~KVRequest_KVPutRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVPutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVPutRequest(const KVRequest_KVPutRequest& from);
  KVRequest_KVPutRequest(KVRequest_KVPutRequest&& from) noexcept
    : KVRequest_KVPutRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVPutRequest& operator=(const KVRequest_KVPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVPutRequest& operator=(KVRequest_KVPutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVPutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVPutRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVPutRequest*>(
               &_KVRequest_KVPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KVRequest_KVPutRequest& a, KVRequest_KVPutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVPutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVPutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVPutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVPutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVPutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVPutRequest& from) {
    KVRequest_KVPutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVPutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVPutRequest";
  }
  protected:
  explicit KVRequest_KVPutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // optional string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVPutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVSputRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVSputRequest) */ {
 public:
  inline KVRequest_KVSputRequest() : KVRequest_KVSputRequest(nullptr) {}
  ~KVRequest_KVSputRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVSputRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVSputRequest(const KVRequest_KVSputRequest& from);
  KVRequest_KVSputRequest(KVRequest_KVSputRequest&& from) noexcept
    : KVRequest_KVSputRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVSputRequest& operator=(const KVRequest_KVSputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVSputRequest& operator=(KVRequest_KVSputRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVSputRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVSputRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVSputRequest*>(
               &_KVRequest_KVSputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KVRequest_KVSputRequest& a, KVRequest_KVSputRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVSputRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVSputRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVSputRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVSputRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVSputRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVSputRequest& from) {
    KVRequest_KVSputRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVSputRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVSputRequest";
  }
  protected:
  explicit KVRequest_KVSputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // optional string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVSputRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVCPutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVCPutRequest) */ {
 public:
  inline KVRequest_KVCPutRequest() : KVRequest_KVCPutRequest(nullptr) {}
  ~KVRequest_KVCPutRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVCPutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVCPutRequest(const KVRequest_KVCPutRequest& from);
  KVRequest_KVCPutRequest(KVRequest_KVCPutRequest&& from) noexcept
    : KVRequest_KVCPutRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVCPutRequest& operator=(const KVRequest_KVCPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVCPutRequest& operator=(KVRequest_KVCPutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVCPutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVCPutRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVCPutRequest*>(
               &_KVRequest_KVCPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(KVRequest_KVCPutRequest& a, KVRequest_KVCPutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVCPutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVCPutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVCPutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVCPutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVCPutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVCPutRequest& from) {
    KVRequest_KVCPutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVCPutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVCPutRequest";
  }
  protected:
  explicit KVRequest_KVCPutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kCurValueFieldNumber = 3,
    kNewValueFieldNumber = 4,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // optional string cur_value = 3;
  bool has_cur_value() const;
  private:
  bool _internal_has_cur_value() const;
  public:
  void clear_cur_value();
  const std::string& cur_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cur_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cur_value();
  PROTOBUF_NODISCARD std::string* release_cur_value();
  void set_allocated_cur_value(std::string* cur_value);
  private:
  const std::string& _internal_cur_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cur_value(const std::string& value);
  std::string* _internal_mutable_cur_value();
  public:

  // optional string new_value = 4;
  bool has_new_value() const;
  private:
  bool _internal_has_new_value() const;
  public:
  void clear_new_value();
  const std::string& new_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_value();
  PROTOBUF_NODISCARD std::string* release_new_value();
  void set_allocated_new_value(std::string* new_value);
  private:
  const std::string& _internal_new_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_value(const std::string& value);
  std::string* _internal_mutable_new_value();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVCPutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cur_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVScputRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVScputRequest) */ {
 public:
  inline KVRequest_KVScputRequest() : KVRequest_KVScputRequest(nullptr) {}
  ~KVRequest_KVScputRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVScputRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVScputRequest(const KVRequest_KVScputRequest& from);
  KVRequest_KVScputRequest(KVRequest_KVScputRequest&& from) noexcept
    : KVRequest_KVScputRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVScputRequest& operator=(const KVRequest_KVScputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVScputRequest& operator=(KVRequest_KVScputRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVScputRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVScputRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVScputRequest*>(
               &_KVRequest_KVScputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(KVRequest_KVScputRequest& a, KVRequest_KVScputRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVScputRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVScputRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVScputRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVScputRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVScputRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVScputRequest& from) {
    KVRequest_KVScputRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVScputRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVScputRequest";
  }
  protected:
  explicit KVRequest_KVScputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kCurValueFieldNumber = 3,
    kNewValueFieldNumber = 4,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // optional string cur_value = 3;
  bool has_cur_value() const;
  private:
  bool _internal_has_cur_value() const;
  public:
  void clear_cur_value();
  const std::string& cur_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cur_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cur_value();
  PROTOBUF_NODISCARD std::string* release_cur_value();
  void set_allocated_cur_value(std::string* cur_value);
  private:
  const std::string& _internal_cur_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cur_value(const std::string& value);
  std::string* _internal_mutable_cur_value();
  public:

  // optional string new_value = 4;
  bool has_new_value() const;
  private:
  bool _internal_has_new_value() const;
  public:
  void clear_new_value();
  const std::string& new_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_value();
  PROTOBUF_NODISCARD std::string* release_new_value();
  void set_allocated_new_value(std::string* new_value);
  private:
  const std::string& _internal_new_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_value(const std::string& value);
  std::string* _internal_mutable_new_value();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVScputRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cur_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVDeleteRequest) */ {
 public:
  inline KVRequest_KVDeleteRequest() : KVRequest_KVDeleteRequest(nullptr) {}
  ~KVRequest_KVDeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVDeleteRequest(const KVRequest_KVDeleteRequest& from);
  KVRequest_KVDeleteRequest(KVRequest_KVDeleteRequest&& from) noexcept
    : KVRequest_KVDeleteRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVDeleteRequest& operator=(const KVRequest_KVDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVDeleteRequest& operator=(KVRequest_KVDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVDeleteRequest*>(
               &_KVRequest_KVDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(KVRequest_KVDeleteRequest& a, KVRequest_KVDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVDeleteRequest& from) {
    KVRequest_KVDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVDeleteRequest";
  }
  protected:
  explicit KVRequest_KVDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVSdeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVSdeleteRequest) */ {
 public:
  inline KVRequest_KVSdeleteRequest() : KVRequest_KVSdeleteRequest(nullptr) {}
  ~KVRequest_KVSdeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVSdeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVSdeleteRequest(const KVRequest_KVSdeleteRequest& from);
  KVRequest_KVSdeleteRequest(KVRequest_KVSdeleteRequest&& from) noexcept
    : KVRequest_KVSdeleteRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVSdeleteRequest& operator=(const KVRequest_KVSdeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVSdeleteRequest& operator=(KVRequest_KVSdeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVSdeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVSdeleteRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVSdeleteRequest*>(
               &_KVRequest_KVSdeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(KVRequest_KVSdeleteRequest& a, KVRequest_KVSdeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVSdeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVSdeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVSdeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVSdeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVSdeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVSdeleteRequest& from) {
    KVRequest_KVSdeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVSdeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVSdeleteRequest";
  }
  protected:
  explicit KVRequest_KVSdeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVSdeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVSuspendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVSuspendRequest) */ {
 public:
  inline KVRequest_KVSuspendRequest() : KVRequest_KVSuspendRequest(nullptr) {}
  ~KVRequest_KVSuspendRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVSuspendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVSuspendRequest(const KVRequest_KVSuspendRequest& from);
  KVRequest_KVSuspendRequest(KVRequest_KVSuspendRequest&& from) noexcept
    : KVRequest_KVSuspendRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVSuspendRequest& operator=(const KVRequest_KVSuspendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVSuspendRequest& operator=(KVRequest_KVSuspendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVSuspendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVSuspendRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVSuspendRequest*>(
               &_KVRequest_KVSuspendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(KVRequest_KVSuspendRequest& a, KVRequest_KVSuspendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVSuspendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVSuspendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVSuspendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVSuspendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVSuspendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVSuspendRequest& from) {
    KVRequest_KVSuspendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVSuspendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVSuspendRequest";
  }
  protected:
  explicit KVRequest_KVSuspendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetAddrFieldNumber = 1,
  };
  // optional string target_addr = 1;
  bool has_target_addr() const;
  private:
  bool _internal_has_target_addr() const;
  public:
  void clear_target_addr();
  const std::string& target_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_addr();
  PROTOBUF_NODISCARD std::string* release_target_addr();
  void set_allocated_target_addr(std::string* target_addr);
  private:
  const std::string& _internal_target_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_addr(const std::string& value);
  std::string* _internal_mutable_target_addr();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVSuspendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_addr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVRecoveryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVRecoveryRequest) */ {
 public:
  inline KVRequest_KVRecoveryRequest() : KVRequest_KVRecoveryRequest(nullptr) {}
  ~KVRequest_KVRecoveryRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVRecoveryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVRecoveryRequest(const KVRequest_KVRecoveryRequest& from);
  KVRequest_KVRecoveryRequest(KVRequest_KVRecoveryRequest&& from) noexcept
    : KVRequest_KVRecoveryRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVRecoveryRequest& operator=(const KVRequest_KVRecoveryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVRecoveryRequest& operator=(KVRequest_KVRecoveryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVRecoveryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVRecoveryRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVRecoveryRequest*>(
               &_KVRequest_KVRecoveryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(KVRequest_KVRecoveryRequest& a, KVRequest_KVRecoveryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVRecoveryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVRecoveryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVRecoveryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVRecoveryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVRecoveryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVRecoveryRequest& from) {
    KVRequest_KVRecoveryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVRecoveryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVRecoveryRequest";
  }
  protected:
  explicit KVRequest_KVRecoveryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetAddrFieldNumber = 1,
  };
  // optional string target_addr = 1;
  bool has_target_addr() const;
  private:
  bool _internal_has_target_addr() const;
  public:
  void clear_target_addr();
  const std::string& target_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_addr();
  PROTOBUF_NODISCARD std::string* release_target_addr();
  void set_allocated_target_addr(std::string* target_addr);
  private:
  const std::string& _internal_target_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_addr(const std::string& value);
  std::string* _internal_mutable_target_addr();
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVRecoveryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_addr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVFiletransferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVFiletransferRequest) */ {
 public:
  inline KVRequest_KVFiletransferRequest() : KVRequest_KVFiletransferRequest(nullptr) {}
  ~KVRequest_KVFiletransferRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVFiletransferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVFiletransferRequest(const KVRequest_KVFiletransferRequest& from);
  KVRequest_KVFiletransferRequest(KVRequest_KVFiletransferRequest&& from) noexcept
    : KVRequest_KVFiletransferRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVFiletransferRequest& operator=(const KVRequest_KVFiletransferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVFiletransferRequest& operator=(KVRequest_KVFiletransferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVFiletransferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVFiletransferRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVFiletransferRequest*>(
               &_KVRequest_KVFiletransferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(KVRequest_KVFiletransferRequest& a, KVRequest_KVFiletransferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVFiletransferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVFiletransferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVFiletransferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVFiletransferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVFiletransferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVFiletransferRequest& from) {
    KVRequest_KVFiletransferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVFiletransferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVFiletransferRequest";
  }
  protected:
  explicit KVRequest_KVFiletransferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
    kFileTypeFieldNumber = 1,
    kTabletIdxFieldNumber = 2,
  };
  // optional string content = 3;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional .FileType file_type = 1;
  bool has_file_type() const;
  private:
  bool _internal_has_file_type() const;
  public:
  void clear_file_type();
  ::FileType file_type() const;
  void set_file_type(::FileType value);
  private:
  ::FileType _internal_file_type() const;
  void _internal_set_file_type(::FileType value);
  public:

  // optional int32 tablet_idx = 2;
  bool has_tablet_idx() const;
  private:
  bool _internal_has_tablet_idx() const;
  public:
  void clear_tablet_idx();
  int32_t tablet_idx() const;
  void set_tablet_idx(int32_t value);
  private:
  int32_t _internal_tablet_idx() const;
  void _internal_set_tablet_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVFiletransferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int file_type_;
    int32_t tablet_idx_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest_KVReplayRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest.KVReplayRequest) */ {
 public:
  inline KVRequest_KVReplayRequest() : KVRequest_KVReplayRequest(nullptr) {}
  ~KVRequest_KVReplayRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest_KVReplayRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest_KVReplayRequest(const KVRequest_KVReplayRequest& from);
  KVRequest_KVReplayRequest(KVRequest_KVReplayRequest&& from) noexcept
    : KVRequest_KVReplayRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest_KVReplayRequest& operator=(const KVRequest_KVReplayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest_KVReplayRequest& operator=(KVRequest_KVReplayRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest_KVReplayRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVRequest_KVReplayRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest_KVReplayRequest*>(
               &_KVRequest_KVReplayRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(KVRequest_KVReplayRequest& a, KVRequest_KVReplayRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest_KVReplayRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest_KVReplayRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest_KVReplayRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest_KVReplayRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest_KVReplayRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest_KVReplayRequest& from) {
    KVRequest_KVReplayRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest_KVReplayRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest.KVReplayRequest";
  }
  protected:
  explicit KVRequest_KVReplayRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabletTargetFieldNumber = 2,
    kTabletNumFieldNumber = 1,
  };
  // optional string tablet_target = 2;
  bool has_tablet_target() const;
  private:
  bool _internal_has_tablet_target() const;
  public:
  void clear_tablet_target();
  const std::string& tablet_target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablet_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablet_target();
  PROTOBUF_NODISCARD std::string* release_tablet_target();
  void set_allocated_tablet_target(std::string* tablet_target);
  private:
  const std::string& _internal_tablet_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablet_target(const std::string& value);
  std::string* _internal_mutable_tablet_target();
  public:

  // optional int32 tablet_num = 1;
  bool has_tablet_num() const;
  private:
  bool _internal_has_tablet_num() const;
  public:
  void clear_tablet_num();
  int32_t tablet_num() const;
  void set_tablet_num(int32_t value);
  private:
  int32_t _internal_tablet_num() const;
  void _internal_set_tablet_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KVRequest.KVReplayRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablet_target_;
    int32_t tablet_num_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVRequest) */ {
 public:
  inline KVRequest() : KVRequest(nullptr) {}
  ~KVRequest() override;
  explicit PROTOBUF_CONSTEXPR KVRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVRequest(const KVRequest& from);
  KVRequest(KVRequest&& from) noexcept
    : KVRequest() {
    *this = ::std::move(from);
  }

  inline KVRequest& operator=(const KVRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVRequest& operator=(KVRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kGetRequest = 1,
    kSgetRequest = 2,
    kPutRequest = 3,
    kSputRequest = 4,
    kCputRequest = 5,
    kScputRequest = 6,
    kDeleteRequest = 7,
    kSdeleteRequest = 8,
    kSuspendRequest = 9,
    kRecoveryRequest = 10,
    kFiletransferRequest = 12,
    kReplayRequest = 13,
    REQUEST_NOT_SET = 0,
  };

  static inline const KVRequest* internal_default_instance() {
    return reinterpret_cast<const KVRequest*>(
               &_KVRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(KVRequest& a, KVRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KVRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVRequest& from) {
    KVRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVRequest";
  }
  protected:
  explicit KVRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KVRequest_KVGetRequest KVGetRequest;
  typedef KVRequest_KVSgetRequest KVSgetRequest;
  typedef KVRequest_KVPutRequest KVPutRequest;
  typedef KVRequest_KVSputRequest KVSputRequest;
  typedef KVRequest_KVCPutRequest KVCPutRequest;
  typedef KVRequest_KVScputRequest KVScputRequest;
  typedef KVRequest_KVDeleteRequest KVDeleteRequest;
  typedef KVRequest_KVSdeleteRequest KVSdeleteRequest;
  typedef KVRequest_KVSuspendRequest KVSuspendRequest;
  typedef KVRequest_KVRecoveryRequest KVRecoveryRequest;
  typedef KVRequest_KVFiletransferRequest KVFiletransferRequest;
  typedef KVRequest_KVReplayRequest KVReplayRequest;

  // accessors -------------------------------------------------------

  enum : int {
    kGetRequestFieldNumber = 1,
    kSgetRequestFieldNumber = 2,
    kPutRequestFieldNumber = 3,
    kSputRequestFieldNumber = 4,
    kCputRequestFieldNumber = 5,
    kScputRequestFieldNumber = 6,
    kDeleteRequestFieldNumber = 7,
    kSdeleteRequestFieldNumber = 8,
    kSuspendRequestFieldNumber = 9,
    kRecoveryRequestFieldNumber = 10,
    kFiletransferRequestFieldNumber = 12,
    kReplayRequestFieldNumber = 13,
  };
  // .KVRequest.KVGetRequest get_request = 1;
  bool has_get_request() const;
  private:
  bool _internal_has_get_request() const;
  public:
  void clear_get_request();
  const ::KVRequest_KVGetRequest& get_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVGetRequest* release_get_request();
  ::KVRequest_KVGetRequest* mutable_get_request();
  void set_allocated_get_request(::KVRequest_KVGetRequest* get_request);
  private:
  const ::KVRequest_KVGetRequest& _internal_get_request() const;
  ::KVRequest_KVGetRequest* _internal_mutable_get_request();
  public:
  void unsafe_arena_set_allocated_get_request(
      ::KVRequest_KVGetRequest* get_request);
  ::KVRequest_KVGetRequest* unsafe_arena_release_get_request();

  // .KVRequest.KVSgetRequest sget_request = 2;
  bool has_sget_request() const;
  private:
  bool _internal_has_sget_request() const;
  public:
  void clear_sget_request();
  const ::KVRequest_KVSgetRequest& sget_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVSgetRequest* release_sget_request();
  ::KVRequest_KVSgetRequest* mutable_sget_request();
  void set_allocated_sget_request(::KVRequest_KVSgetRequest* sget_request);
  private:
  const ::KVRequest_KVSgetRequest& _internal_sget_request() const;
  ::KVRequest_KVSgetRequest* _internal_mutable_sget_request();
  public:
  void unsafe_arena_set_allocated_sget_request(
      ::KVRequest_KVSgetRequest* sget_request);
  ::KVRequest_KVSgetRequest* unsafe_arena_release_sget_request();

  // .KVRequest.KVPutRequest put_request = 3;
  bool has_put_request() const;
  private:
  bool _internal_has_put_request() const;
  public:
  void clear_put_request();
  const ::KVRequest_KVPutRequest& put_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVPutRequest* release_put_request();
  ::KVRequest_KVPutRequest* mutable_put_request();
  void set_allocated_put_request(::KVRequest_KVPutRequest* put_request);
  private:
  const ::KVRequest_KVPutRequest& _internal_put_request() const;
  ::KVRequest_KVPutRequest* _internal_mutable_put_request();
  public:
  void unsafe_arena_set_allocated_put_request(
      ::KVRequest_KVPutRequest* put_request);
  ::KVRequest_KVPutRequest* unsafe_arena_release_put_request();

  // .KVRequest.KVSputRequest sput_request = 4;
  bool has_sput_request() const;
  private:
  bool _internal_has_sput_request() const;
  public:
  void clear_sput_request();
  const ::KVRequest_KVSputRequest& sput_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVSputRequest* release_sput_request();
  ::KVRequest_KVSputRequest* mutable_sput_request();
  void set_allocated_sput_request(::KVRequest_KVSputRequest* sput_request);
  private:
  const ::KVRequest_KVSputRequest& _internal_sput_request() const;
  ::KVRequest_KVSputRequest* _internal_mutable_sput_request();
  public:
  void unsafe_arena_set_allocated_sput_request(
      ::KVRequest_KVSputRequest* sput_request);
  ::KVRequest_KVSputRequest* unsafe_arena_release_sput_request();

  // .KVRequest.KVCPutRequest cput_request = 5;
  bool has_cput_request() const;
  private:
  bool _internal_has_cput_request() const;
  public:
  void clear_cput_request();
  const ::KVRequest_KVCPutRequest& cput_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVCPutRequest* release_cput_request();
  ::KVRequest_KVCPutRequest* mutable_cput_request();
  void set_allocated_cput_request(::KVRequest_KVCPutRequest* cput_request);
  private:
  const ::KVRequest_KVCPutRequest& _internal_cput_request() const;
  ::KVRequest_KVCPutRequest* _internal_mutable_cput_request();
  public:
  void unsafe_arena_set_allocated_cput_request(
      ::KVRequest_KVCPutRequest* cput_request);
  ::KVRequest_KVCPutRequest* unsafe_arena_release_cput_request();

  // .KVRequest.KVScputRequest scput_request = 6;
  bool has_scput_request() const;
  private:
  bool _internal_has_scput_request() const;
  public:
  void clear_scput_request();
  const ::KVRequest_KVScputRequest& scput_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVScputRequest* release_scput_request();
  ::KVRequest_KVScputRequest* mutable_scput_request();
  void set_allocated_scput_request(::KVRequest_KVScputRequest* scput_request);
  private:
  const ::KVRequest_KVScputRequest& _internal_scput_request() const;
  ::KVRequest_KVScputRequest* _internal_mutable_scput_request();
  public:
  void unsafe_arena_set_allocated_scput_request(
      ::KVRequest_KVScputRequest* scput_request);
  ::KVRequest_KVScputRequest* unsafe_arena_release_scput_request();

  // .KVRequest.KVDeleteRequest delete_request = 7;
  bool has_delete_request() const;
  private:
  bool _internal_has_delete_request() const;
  public:
  void clear_delete_request();
  const ::KVRequest_KVDeleteRequest& delete_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVDeleteRequest* release_delete_request();
  ::KVRequest_KVDeleteRequest* mutable_delete_request();
  void set_allocated_delete_request(::KVRequest_KVDeleteRequest* delete_request);
  private:
  const ::KVRequest_KVDeleteRequest& _internal_delete_request() const;
  ::KVRequest_KVDeleteRequest* _internal_mutable_delete_request();
  public:
  void unsafe_arena_set_allocated_delete_request(
      ::KVRequest_KVDeleteRequest* delete_request);
  ::KVRequest_KVDeleteRequest* unsafe_arena_release_delete_request();

  // .KVRequest.KVSdeleteRequest sdelete_request = 8;
  bool has_sdelete_request() const;
  private:
  bool _internal_has_sdelete_request() const;
  public:
  void clear_sdelete_request();
  const ::KVRequest_KVSdeleteRequest& sdelete_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVSdeleteRequest* release_sdelete_request();
  ::KVRequest_KVSdeleteRequest* mutable_sdelete_request();
  void set_allocated_sdelete_request(::KVRequest_KVSdeleteRequest* sdelete_request);
  private:
  const ::KVRequest_KVSdeleteRequest& _internal_sdelete_request() const;
  ::KVRequest_KVSdeleteRequest* _internal_mutable_sdelete_request();
  public:
  void unsafe_arena_set_allocated_sdelete_request(
      ::KVRequest_KVSdeleteRequest* sdelete_request);
  ::KVRequest_KVSdeleteRequest* unsafe_arena_release_sdelete_request();

  // .KVRequest.KVSuspendRequest suspend_request = 9;
  bool has_suspend_request() const;
  private:
  bool _internal_has_suspend_request() const;
  public:
  void clear_suspend_request();
  const ::KVRequest_KVSuspendRequest& suspend_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVSuspendRequest* release_suspend_request();
  ::KVRequest_KVSuspendRequest* mutable_suspend_request();
  void set_allocated_suspend_request(::KVRequest_KVSuspendRequest* suspend_request);
  private:
  const ::KVRequest_KVSuspendRequest& _internal_suspend_request() const;
  ::KVRequest_KVSuspendRequest* _internal_mutable_suspend_request();
  public:
  void unsafe_arena_set_allocated_suspend_request(
      ::KVRequest_KVSuspendRequest* suspend_request);
  ::KVRequest_KVSuspendRequest* unsafe_arena_release_suspend_request();

  // .KVRequest.KVRecoveryRequest recovery_request = 10;
  bool has_recovery_request() const;
  private:
  bool _internal_has_recovery_request() const;
  public:
  void clear_recovery_request();
  const ::KVRequest_KVRecoveryRequest& recovery_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVRecoveryRequest* release_recovery_request();
  ::KVRequest_KVRecoveryRequest* mutable_recovery_request();
  void set_allocated_recovery_request(::KVRequest_KVRecoveryRequest* recovery_request);
  private:
  const ::KVRequest_KVRecoveryRequest& _internal_recovery_request() const;
  ::KVRequest_KVRecoveryRequest* _internal_mutable_recovery_request();
  public:
  void unsafe_arena_set_allocated_recovery_request(
      ::KVRequest_KVRecoveryRequest* recovery_request);
  ::KVRequest_KVRecoveryRequest* unsafe_arena_release_recovery_request();

  // .KVRequest.KVFiletransferRequest filetransfer_request = 12;
  bool has_filetransfer_request() const;
  private:
  bool _internal_has_filetransfer_request() const;
  public:
  void clear_filetransfer_request();
  const ::KVRequest_KVFiletransferRequest& filetransfer_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVFiletransferRequest* release_filetransfer_request();
  ::KVRequest_KVFiletransferRequest* mutable_filetransfer_request();
  void set_allocated_filetransfer_request(::KVRequest_KVFiletransferRequest* filetransfer_request);
  private:
  const ::KVRequest_KVFiletransferRequest& _internal_filetransfer_request() const;
  ::KVRequest_KVFiletransferRequest* _internal_mutable_filetransfer_request();
  public:
  void unsafe_arena_set_allocated_filetransfer_request(
      ::KVRequest_KVFiletransferRequest* filetransfer_request);
  ::KVRequest_KVFiletransferRequest* unsafe_arena_release_filetransfer_request();

  // .KVRequest.KVReplayRequest replay_request = 13;
  bool has_replay_request() const;
  private:
  bool _internal_has_replay_request() const;
  public:
  void clear_replay_request();
  const ::KVRequest_KVReplayRequest& replay_request() const;
  PROTOBUF_NODISCARD ::KVRequest_KVReplayRequest* release_replay_request();
  ::KVRequest_KVReplayRequest* mutable_replay_request();
  void set_allocated_replay_request(::KVRequest_KVReplayRequest* replay_request);
  private:
  const ::KVRequest_KVReplayRequest& _internal_replay_request() const;
  ::KVRequest_KVReplayRequest* _internal_mutable_replay_request();
  public:
  void unsafe_arena_set_allocated_replay_request(
      ::KVRequest_KVReplayRequest* replay_request);
  ::KVRequest_KVReplayRequest* unsafe_arena_release_replay_request();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:KVRequest)
 private:
  class _Internal;
  void set_has_get_request();
  void set_has_sget_request();
  void set_has_put_request();
  void set_has_sput_request();
  void set_has_cput_request();
  void set_has_scput_request();
  void set_has_delete_request();
  void set_has_sdelete_request();
  void set_has_suspend_request();
  void set_has_recovery_request();
  void set_has_filetransfer_request();
  void set_has_replay_request();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::KVRequest_KVGetRequest* get_request_;
      ::KVRequest_KVSgetRequest* sget_request_;
      ::KVRequest_KVPutRequest* put_request_;
      ::KVRequest_KVSputRequest* sput_request_;
      ::KVRequest_KVCPutRequest* cput_request_;
      ::KVRequest_KVScputRequest* scput_request_;
      ::KVRequest_KVDeleteRequest* delete_request_;
      ::KVRequest_KVSdeleteRequest* sdelete_request_;
      ::KVRequest_KVSuspendRequest* suspend_request_;
      ::KVRequest_KVRecoveryRequest* recovery_request_;
      ::KVRequest_KVFiletransferRequest* filetransfer_request_;
      ::KVRequest_KVReplayRequest* replay_request_;
    } request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class KVResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KVResponse) */ {
 public:
  inline KVResponse() : KVResponse(nullptr) {}
  ~KVResponse() override;
  explicit PROTOBUF_CONSTEXPR KVResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVResponse(const KVResponse& from);
  KVResponse(KVResponse&& from) noexcept
    : KVResponse() {
    *this = ::std::move(from);
  }

  inline KVResponse& operator=(const KVResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVResponse& operator=(KVResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVResponse* internal_default_instance() {
    return reinterpret_cast<const KVResponse*>(
               &_KVResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(KVResponse& a, KVResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KVResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVResponse& from) {
    KVResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KVResponse";
  }
  protected:
  explicit KVResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional .KVStatusCode status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::KVStatusCode status() const;
  void set_status(::KVStatusCode value);
  private:
  ::KVStatusCode _internal_status() const;
  void _internal_set_status(::KVStatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:KVResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class FetchNodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FetchNodeRequest) */ {
 public:
  inline FetchNodeRequest() : FetchNodeRequest(nullptr) {}
  ~FetchNodeRequest() override;
  explicit PROTOBUF_CONSTEXPR FetchNodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchNodeRequest(const FetchNodeRequest& from);
  FetchNodeRequest(FetchNodeRequest&& from) noexcept
    : FetchNodeRequest() {
    *this = ::std::move(from);
  }

  inline FetchNodeRequest& operator=(const FetchNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchNodeRequest& operator=(FetchNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchNodeRequest* internal_default_instance() {
    return reinterpret_cast<const FetchNodeRequest*>(
               &_FetchNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FetchNodeRequest& a, FetchNodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchNodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchNodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchNodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchNodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchNodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchNodeRequest& from) {
    FetchNodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchNodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FetchNodeRequest";
  }
  protected:
  explicit FetchNodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // optional string row = 1;
  bool has_row() const;
  private:
  bool _internal_has_row() const;
  public:
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // optional string col = 2;
  bool has_col() const;
  private:
  bool _internal_has_col() const;
  public:
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // @@protoc_insertion_point(class_scope:FetchNodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class FetchNodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FetchNodeResponse) */ {
 public:
  inline FetchNodeResponse() : FetchNodeResponse(nullptr) {}
  ~FetchNodeResponse() override;
  explicit PROTOBUF_CONSTEXPR FetchNodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchNodeResponse(const FetchNodeResponse& from);
  FetchNodeResponse(FetchNodeResponse&& from) noexcept
    : FetchNodeResponse() {
    *this = ::std::move(from);
  }

  inline FetchNodeResponse& operator=(const FetchNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchNodeResponse& operator=(FetchNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchNodeResponse* internal_default_instance() {
    return reinterpret_cast<const FetchNodeResponse*>(
               &_FetchNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FetchNodeResponse& a, FetchNodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchNodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchNodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchNodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchNodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchNodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchNodeResponse& from) {
    FetchNodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchNodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FetchNodeResponse";
  }
  protected:
  explicit FetchNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string addr = 2;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // optional string error_message = 3;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional .KVStatusCode status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::KVStatusCode status() const;
  void set_status(::KVStatusCode value);
  private:
  ::KVStatusCode _internal_status() const;
  void _internal_set_status(::KVStatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:FetchNodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class PollStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PollStatusRequest) */ {
 public:
  inline PollStatusRequest() : PollStatusRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PollStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PollStatusRequest(const PollStatusRequest& from);
  PollStatusRequest(PollStatusRequest&& from) noexcept
    : PollStatusRequest() {
    *this = ::std::move(from);
  }

  inline PollStatusRequest& operator=(const PollStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollStatusRequest& operator=(PollStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollStatusRequest* internal_default_instance() {
    return reinterpret_cast<const PollStatusRequest*>(
               &_PollStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PollStatusRequest& a, PollStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PollStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PollStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PollStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PollStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PollStatusRequest";
  }
  protected:
  explicit PollStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PollStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class PollStatusResponse_Cluster_Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PollStatusResponse.Cluster.Node) */ {
 public:
  inline PollStatusResponse_Cluster_Node() : PollStatusResponse_Cluster_Node(nullptr) {}
  ~PollStatusResponse_Cluster_Node() override;
  explicit PROTOBUF_CONSTEXPR PollStatusResponse_Cluster_Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PollStatusResponse_Cluster_Node(const PollStatusResponse_Cluster_Node& from);
  PollStatusResponse_Cluster_Node(PollStatusResponse_Cluster_Node&& from) noexcept
    : PollStatusResponse_Cluster_Node() {
    *this = ::std::move(from);
  }

  inline PollStatusResponse_Cluster_Node& operator=(const PollStatusResponse_Cluster_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollStatusResponse_Cluster_Node& operator=(PollStatusResponse_Cluster_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollStatusResponse_Cluster_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollStatusResponse_Cluster_Node* internal_default_instance() {
    return reinterpret_cast<const PollStatusResponse_Cluster_Node*>(
               &_PollStatusResponse_Cluster_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PollStatusResponse_Cluster_Node& a, PollStatusResponse_Cluster_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(PollStatusResponse_Cluster_Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollStatusResponse_Cluster_Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollStatusResponse_Cluster_Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PollStatusResponse_Cluster_Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PollStatusResponse_Cluster_Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PollStatusResponse_Cluster_Node& from) {
    PollStatusResponse_Cluster_Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PollStatusResponse_Cluster_Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PollStatusResponse.Cluster.Node";
  }
  protected:
  explicit PollStatusResponse_Cluster_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kStateFieldNumber = 3,
    kIsPrimaryFieldNumber = 1,
  };
  // optional string address = 2;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional bool is_primary = 1;
  bool has_is_primary() const;
  private:
  bool _internal_has_is_primary() const;
  public:
  void clear_is_primary();
  bool is_primary() const;
  void set_is_primary(bool value);
  private:
  bool _internal_is_primary() const;
  void _internal_set_is_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PollStatusResponse.Cluster.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    bool is_primary_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class PollStatusResponse_Cluster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PollStatusResponse.Cluster) */ {
 public:
  inline PollStatusResponse_Cluster() : PollStatusResponse_Cluster(nullptr) {}
  ~PollStatusResponse_Cluster() override;
  explicit PROTOBUF_CONSTEXPR PollStatusResponse_Cluster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PollStatusResponse_Cluster(const PollStatusResponse_Cluster& from);
  PollStatusResponse_Cluster(PollStatusResponse_Cluster&& from) noexcept
    : PollStatusResponse_Cluster() {
    *this = ::std::move(from);
  }

  inline PollStatusResponse_Cluster& operator=(const PollStatusResponse_Cluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollStatusResponse_Cluster& operator=(PollStatusResponse_Cluster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollStatusResponse_Cluster& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollStatusResponse_Cluster* internal_default_instance() {
    return reinterpret_cast<const PollStatusResponse_Cluster*>(
               &_PollStatusResponse_Cluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PollStatusResponse_Cluster& a, PollStatusResponse_Cluster& b) {
    a.Swap(&b);
  }
  inline void Swap(PollStatusResponse_Cluster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollStatusResponse_Cluster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollStatusResponse_Cluster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PollStatusResponse_Cluster>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PollStatusResponse_Cluster& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PollStatusResponse_Cluster& from) {
    PollStatusResponse_Cluster::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PollStatusResponse_Cluster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PollStatusResponse.Cluster";
  }
  protected:
  explicit PollStatusResponse_Cluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PollStatusResponse_Cluster_Node Node;

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .PollStatusResponse.Cluster.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::PollStatusResponse_Cluster_Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster_Node >*
      mutable_nodes();
  private:
  const ::PollStatusResponse_Cluster_Node& _internal_nodes(int index) const;
  ::PollStatusResponse_Cluster_Node* _internal_add_nodes();
  public:
  const ::PollStatusResponse_Cluster_Node& nodes(int index) const;
  ::PollStatusResponse_Cluster_Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster_Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:PollStatusResponse.Cluster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster_Node > nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class PollStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PollStatusResponse) */ {
 public:
  inline PollStatusResponse() : PollStatusResponse(nullptr) {}
  ~PollStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR PollStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PollStatusResponse(const PollStatusResponse& from);
  PollStatusResponse(PollStatusResponse&& from) noexcept
    : PollStatusResponse() {
    *this = ::std::move(from);
  }

  inline PollStatusResponse& operator=(const PollStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollStatusResponse& operator=(PollStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PollStatusResponse* internal_default_instance() {
    return reinterpret_cast<const PollStatusResponse*>(
               &_PollStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PollStatusResponse& a, PollStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PollStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PollStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PollStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PollStatusResponse& from) {
    PollStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PollStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PollStatusResponse";
  }
  protected:
  explicit PollStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PollStatusResponse_Cluster Cluster;

  // accessors -------------------------------------------------------

  enum : int {
    kClustersFieldNumber = 1,
  };
  // repeated .PollStatusResponse.Cluster clusters = 1;
  int clusters_size() const;
  private:
  int _internal_clusters_size() const;
  public:
  void clear_clusters();
  ::PollStatusResponse_Cluster* mutable_clusters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster >*
      mutable_clusters();
  private:
  const ::PollStatusResponse_Cluster& _internal_clusters(int index) const;
  ::PollStatusResponse_Cluster* _internal_add_clusters();
  public:
  const ::PollStatusResponse_Cluster& clusters(int index) const;
  ::PollStatusResponse_Cluster* add_clusters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster >&
      clusters() const;

  // @@protoc_insertion_point(class_scope:PollStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster > clusters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class SuspendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SuspendRequest) */ {
 public:
  inline SuspendRequest() : SuspendRequest(nullptr) {}
  ~SuspendRequest() override;
  explicit PROTOBUF_CONSTEXPR SuspendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SuspendRequest(const SuspendRequest& from);
  SuspendRequest(SuspendRequest&& from) noexcept
    : SuspendRequest() {
    *this = ::std::move(from);
  }

  inline SuspendRequest& operator=(const SuspendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuspendRequest& operator=(SuspendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuspendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuspendRequest* internal_default_instance() {
    return reinterpret_cast<const SuspendRequest*>(
               &_SuspendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SuspendRequest& a, SuspendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SuspendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuspendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuspendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuspendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SuspendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SuspendRequest& from) {
    SuspendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuspendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SuspendRequest";
  }
  protected:
  explicit SuspendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeAddrFieldNumber = 2,
    kClusterIdFieldNumber = 1,
  };
  // optional string node_addr = 2;
  bool has_node_addr() const;
  private:
  bool _internal_has_node_addr() const;
  public:
  void clear_node_addr();
  const std::string& node_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_addr();
  PROTOBUF_NODISCARD std::string* release_node_addr();
  void set_allocated_node_addr(std::string* node_addr);
  private:
  const std::string& _internal_node_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_addr(const std::string& value);
  std::string* _internal_mutable_node_addr();
  public:

  // optional int32 cluster_id = 1;
  bool has_cluster_id() const;
  private:
  bool _internal_has_cluster_id() const;
  public:
  void clear_cluster_id();
  int32_t cluster_id() const;
  void set_cluster_id(int32_t value);
  private:
  int32_t _internal_cluster_id() const;
  void _internal_set_cluster_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SuspendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_addr_;
    int32_t cluster_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class ReviveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReviveRequest) */ {
 public:
  inline ReviveRequest() : ReviveRequest(nullptr) {}
  ~ReviveRequest() override;
  explicit PROTOBUF_CONSTEXPR ReviveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReviveRequest(const ReviveRequest& from);
  ReviveRequest(ReviveRequest&& from) noexcept
    : ReviveRequest() {
    *this = ::std::move(from);
  }

  inline ReviveRequest& operator=(const ReviveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReviveRequest& operator=(ReviveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReviveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReviveRequest* internal_default_instance() {
    return reinterpret_cast<const ReviveRequest*>(
               &_ReviveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ReviveRequest& a, ReviveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReviveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReviveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReviveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReviveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReviveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReviveRequest& from) {
    ReviveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReviveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReviveRequest";
  }
  protected:
  explicit ReviveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeAddrFieldNumber = 2,
    kClusterIdFieldNumber = 1,
  };
  // optional string node_addr = 2;
  bool has_node_addr() const;
  private:
  bool _internal_has_node_addr() const;
  public:
  void clear_node_addr();
  const std::string& node_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_addr();
  PROTOBUF_NODISCARD std::string* release_node_addr();
  void set_allocated_node_addr(std::string* node_addr);
  private:
  const std::string& _internal_node_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_addr(const std::string& value);
  std::string* _internal_mutable_node_addr();
  public:

  // optional int32 cluster_id = 1;
  bool has_cluster_id() const;
  private:
  bool _internal_has_cluster_id() const;
  public:
  void clear_cluster_id();
  int32_t cluster_id() const;
  void set_cluster_id(int32_t value);
  private:
  int32_t _internal_cluster_id() const;
  void _internal_set_cluster_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReviveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_addr_;
    int32_t cluster_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// -------------------------------------------------------------------

class NotifyRecoveryFinishedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyRecoveryFinishedRequest) */ {
 public:
  inline NotifyRecoveryFinishedRequest() : NotifyRecoveryFinishedRequest(nullptr) {}
  ~NotifyRecoveryFinishedRequest() override;
  explicit PROTOBUF_CONSTEXPR NotifyRecoveryFinishedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyRecoveryFinishedRequest(const NotifyRecoveryFinishedRequest& from);
  NotifyRecoveryFinishedRequest(NotifyRecoveryFinishedRequest&& from) noexcept
    : NotifyRecoveryFinishedRequest() {
    *this = ::std::move(from);
  }

  inline NotifyRecoveryFinishedRequest& operator=(const NotifyRecoveryFinishedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRecoveryFinishedRequest& operator=(NotifyRecoveryFinishedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRecoveryFinishedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRecoveryFinishedRequest* internal_default_instance() {
    return reinterpret_cast<const NotifyRecoveryFinishedRequest*>(
               &_NotifyRecoveryFinishedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(NotifyRecoveryFinishedRequest& a, NotifyRecoveryFinishedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyRecoveryFinishedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRecoveryFinishedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRecoveryFinishedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyRecoveryFinishedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyRecoveryFinishedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyRecoveryFinishedRequest& from) {
    NotifyRecoveryFinishedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyRecoveryFinishedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyRecoveryFinishedRequest";
  }
  protected:
  explicit NotifyRecoveryFinishedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetAddrFieldNumber = 1,
  };
  // optional string target_addr = 1;
  bool has_target_addr() const;
  private:
  bool _internal_has_target_addr() const;
  public:
  void clear_target_addr();
  const std::string& target_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_addr();
  PROTOBUF_NODISCARD std::string* release_target_addr();
  void set_allocated_target_addr(std::string* target_addr);
  private:
  const std::string& _internal_target_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_addr(const std::string& value);
  std::string* _internal_mutable_target_addr();
  public:

  // @@protoc_insertion_point(class_scope:NotifyRecoveryFinishedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_addr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kvstore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KVRequest_KVGetRequest

// optional string row = 1;
inline bool KVRequest_KVGetRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVGetRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVGetRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVGetRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVGetRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVGetRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVGetRequest.row)
}
inline std::string* KVRequest_KVGetRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVGetRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVGetRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVGetRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVGetRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVGetRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVGetRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVGetRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVGetRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVGetRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVGetRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVGetRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVGetRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVGetRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVGetRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVGetRequest.col)
}
inline std::string* KVRequest_KVGetRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVGetRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVGetRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVGetRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVGetRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVGetRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVGetRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVGetRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVGetRequest.col)
}

// -------------------------------------------------------------------

// KVRequest_KVSgetRequest

// optional string row = 1;
inline bool KVRequest_KVSgetRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVSgetRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVSgetRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVSgetRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSgetRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSgetRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSgetRequest.row)
}
inline std::string* KVRequest_KVSgetRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSgetRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVSgetRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVSgetRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSgetRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSgetRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSgetRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSgetRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSgetRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVSgetRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVSgetRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVSgetRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVSgetRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSgetRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSgetRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSgetRequest.col)
}
inline std::string* KVRequest_KVSgetRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSgetRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVSgetRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVSgetRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSgetRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSgetRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSgetRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSgetRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSgetRequest.col)
}

// -------------------------------------------------------------------

// KVRequest_KVPutRequest

// optional string row = 1;
inline bool KVRequest_KVPutRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVPutRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVPutRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVPutRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVPutRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVPutRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVPutRequest.row)
}
inline std::string* KVRequest_KVPutRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVPutRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVPutRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVPutRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVPutRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVPutRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVPutRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVPutRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVPutRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVPutRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVPutRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVPutRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVPutRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVPutRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVPutRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVPutRequest.col)
}
inline std::string* KVRequest_KVPutRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVPutRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVPutRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVPutRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVPutRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVPutRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVPutRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVPutRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVPutRequest.col)
}

// optional string value = 3;
inline bool KVRequest_KVPutRequest::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KVRequest_KVPutRequest::has_value() const {
  return _internal_has_value();
}
inline void KVRequest_KVPutRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& KVRequest_KVPutRequest::value() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVPutRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVPutRequest::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVPutRequest.value)
}
inline std::string* KVRequest_KVPutRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVPutRequest.value)
  return _s;
}
inline const std::string& KVRequest_KVPutRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void KVRequest_KVPutRequest::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVPutRequest::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:KVRequest.KVPutRequest.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVPutRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVPutRequest.value)
}

// -------------------------------------------------------------------

// KVRequest_KVSputRequest

// optional string row = 1;
inline bool KVRequest_KVSputRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVSputRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVSputRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVSputRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSputRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSputRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSputRequest.row)
}
inline std::string* KVRequest_KVSputRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSputRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVSputRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVSputRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSputRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSputRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSputRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSputRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSputRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVSputRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVSputRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVSputRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVSputRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSputRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSputRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSputRequest.col)
}
inline std::string* KVRequest_KVSputRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSputRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVSputRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVSputRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSputRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSputRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSputRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSputRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSputRequest.col)
}

// optional string value = 3;
inline bool KVRequest_KVSputRequest::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KVRequest_KVSputRequest::has_value() const {
  return _internal_has_value();
}
inline void KVRequest_KVSputRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& KVRequest_KVSputRequest::value() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSputRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSputRequest::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSputRequest.value)
}
inline std::string* KVRequest_KVSputRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSputRequest.value)
  return _s;
}
inline const std::string& KVRequest_KVSputRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void KVRequest_KVSputRequest::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSputRequest::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSputRequest::release_value() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSputRequest.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSputRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSputRequest.value)
}

// -------------------------------------------------------------------

// KVRequest_KVCPutRequest

// optional string row = 1;
inline bool KVRequest_KVCPutRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVCPutRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVCPutRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVCPutRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVCPutRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVCPutRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVCPutRequest.row)
}
inline std::string* KVRequest_KVCPutRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVCPutRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVCPutRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVCPutRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVCPutRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVCPutRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVCPutRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVCPutRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVCPutRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVCPutRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVCPutRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVCPutRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVCPutRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVCPutRequest.col)
}
inline std::string* KVRequest_KVCPutRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVCPutRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVCPutRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVCPutRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVCPutRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVCPutRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVCPutRequest.col)
}

// optional string cur_value = 3;
inline bool KVRequest_KVCPutRequest::_internal_has_cur_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KVRequest_KVCPutRequest::has_cur_value() const {
  return _internal_has_cur_value();
}
inline void KVRequest_KVCPutRequest::clear_cur_value() {
  _impl_.cur_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& KVRequest_KVCPutRequest::cur_value() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVCPutRequest.cur_value)
  return _internal_cur_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVCPutRequest::set_cur_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.cur_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVCPutRequest.cur_value)
}
inline std::string* KVRequest_KVCPutRequest::mutable_cur_value() {
  std::string* _s = _internal_mutable_cur_value();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVCPutRequest.cur_value)
  return _s;
}
inline const std::string& KVRequest_KVCPutRequest::_internal_cur_value() const {
  return _impl_.cur_value_.Get();
}
inline void KVRequest_KVCPutRequest::_internal_set_cur_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cur_value_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::_internal_mutable_cur_value() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.cur_value_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::release_cur_value() {
  // @@protoc_insertion_point(field_release:KVRequest.KVCPutRequest.cur_value)
  if (!_internal_has_cur_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.cur_value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cur_value_.IsDefault()) {
    _impl_.cur_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVCPutRequest::set_allocated_cur_value(std::string* cur_value) {
  if (cur_value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cur_value_.SetAllocated(cur_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cur_value_.IsDefault()) {
    _impl_.cur_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVCPutRequest.cur_value)
}

// optional string new_value = 4;
inline bool KVRequest_KVCPutRequest::_internal_has_new_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KVRequest_KVCPutRequest::has_new_value() const {
  return _internal_has_new_value();
}
inline void KVRequest_KVCPutRequest::clear_new_value() {
  _impl_.new_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& KVRequest_KVCPutRequest::new_value() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVCPutRequest.new_value)
  return _internal_new_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVCPutRequest::set_new_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.new_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVCPutRequest.new_value)
}
inline std::string* KVRequest_KVCPutRequest::mutable_new_value() {
  std::string* _s = _internal_mutable_new_value();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVCPutRequest.new_value)
  return _s;
}
inline const std::string& KVRequest_KVCPutRequest::_internal_new_value() const {
  return _impl_.new_value_.Get();
}
inline void KVRequest_KVCPutRequest::_internal_set_new_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.new_value_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::_internal_mutable_new_value() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.new_value_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVCPutRequest::release_new_value() {
  // @@protoc_insertion_point(field_release:KVRequest.KVCPutRequest.new_value)
  if (!_internal_has_new_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.new_value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_value_.IsDefault()) {
    _impl_.new_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVCPutRequest::set_allocated_new_value(std::string* new_value) {
  if (new_value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.new_value_.SetAllocated(new_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_value_.IsDefault()) {
    _impl_.new_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVCPutRequest.new_value)
}

// -------------------------------------------------------------------

// KVRequest_KVScputRequest

// optional string row = 1;
inline bool KVRequest_KVScputRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVScputRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVScputRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVScputRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVScputRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVScputRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVScputRequest.row)
}
inline std::string* KVRequest_KVScputRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVScputRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVScputRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVScputRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVScputRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVScputRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVScputRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVScputRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVScputRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVScputRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVScputRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVScputRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVScputRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVScputRequest.col)
}
inline std::string* KVRequest_KVScputRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVScputRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVScputRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVScputRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVScputRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVScputRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVScputRequest.col)
}

// optional string cur_value = 3;
inline bool KVRequest_KVScputRequest::_internal_has_cur_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KVRequest_KVScputRequest::has_cur_value() const {
  return _internal_has_cur_value();
}
inline void KVRequest_KVScputRequest::clear_cur_value() {
  _impl_.cur_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& KVRequest_KVScputRequest::cur_value() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVScputRequest.cur_value)
  return _internal_cur_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVScputRequest::set_cur_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.cur_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVScputRequest.cur_value)
}
inline std::string* KVRequest_KVScputRequest::mutable_cur_value() {
  std::string* _s = _internal_mutable_cur_value();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVScputRequest.cur_value)
  return _s;
}
inline const std::string& KVRequest_KVScputRequest::_internal_cur_value() const {
  return _impl_.cur_value_.Get();
}
inline void KVRequest_KVScputRequest::_internal_set_cur_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cur_value_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::_internal_mutable_cur_value() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.cur_value_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::release_cur_value() {
  // @@protoc_insertion_point(field_release:KVRequest.KVScputRequest.cur_value)
  if (!_internal_has_cur_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.cur_value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cur_value_.IsDefault()) {
    _impl_.cur_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVScputRequest::set_allocated_cur_value(std::string* cur_value) {
  if (cur_value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cur_value_.SetAllocated(cur_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cur_value_.IsDefault()) {
    _impl_.cur_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVScputRequest.cur_value)
}

// optional string new_value = 4;
inline bool KVRequest_KVScputRequest::_internal_has_new_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KVRequest_KVScputRequest::has_new_value() const {
  return _internal_has_new_value();
}
inline void KVRequest_KVScputRequest::clear_new_value() {
  _impl_.new_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& KVRequest_KVScputRequest::new_value() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVScputRequest.new_value)
  return _internal_new_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVScputRequest::set_new_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.new_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVScputRequest.new_value)
}
inline std::string* KVRequest_KVScputRequest::mutable_new_value() {
  std::string* _s = _internal_mutable_new_value();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVScputRequest.new_value)
  return _s;
}
inline const std::string& KVRequest_KVScputRequest::_internal_new_value() const {
  return _impl_.new_value_.Get();
}
inline void KVRequest_KVScputRequest::_internal_set_new_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.new_value_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::_internal_mutable_new_value() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.new_value_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVScputRequest::release_new_value() {
  // @@protoc_insertion_point(field_release:KVRequest.KVScputRequest.new_value)
  if (!_internal_has_new_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.new_value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_value_.IsDefault()) {
    _impl_.new_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVScputRequest::set_allocated_new_value(std::string* new_value) {
  if (new_value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.new_value_.SetAllocated(new_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_value_.IsDefault()) {
    _impl_.new_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVScputRequest.new_value)
}

// -------------------------------------------------------------------

// KVRequest_KVDeleteRequest

// optional string row = 1;
inline bool KVRequest_KVDeleteRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVDeleteRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVDeleteRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVDeleteRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVDeleteRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVDeleteRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVDeleteRequest.row)
}
inline std::string* KVRequest_KVDeleteRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVDeleteRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVDeleteRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVDeleteRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVDeleteRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVDeleteRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVDeleteRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVDeleteRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVDeleteRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVDeleteRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVDeleteRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVDeleteRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVDeleteRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVDeleteRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVDeleteRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVDeleteRequest.col)
}
inline std::string* KVRequest_KVDeleteRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVDeleteRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVDeleteRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVDeleteRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVDeleteRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVDeleteRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVDeleteRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVDeleteRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVDeleteRequest.col)
}

// -------------------------------------------------------------------

// KVRequest_KVSdeleteRequest

// optional string row = 1;
inline bool KVRequest_KVSdeleteRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVSdeleteRequest::has_row() const {
  return _internal_has_row();
}
inline void KVRequest_KVSdeleteRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVSdeleteRequest::row() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSdeleteRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSdeleteRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSdeleteRequest.row)
}
inline std::string* KVRequest_KVSdeleteRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSdeleteRequest.row)
  return _s;
}
inline const std::string& KVRequest_KVSdeleteRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void KVRequest_KVSdeleteRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSdeleteRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSdeleteRequest::release_row() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSdeleteRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSdeleteRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSdeleteRequest.row)
}

// optional string col = 2;
inline bool KVRequest_KVSdeleteRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVSdeleteRequest::has_col() const {
  return _internal_has_col();
}
inline void KVRequest_KVSdeleteRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KVRequest_KVSdeleteRequest::col() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSdeleteRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSdeleteRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSdeleteRequest.col)
}
inline std::string* KVRequest_KVSdeleteRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSdeleteRequest.col)
  return _s;
}
inline const std::string& KVRequest_KVSdeleteRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void KVRequest_KVSdeleteRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSdeleteRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSdeleteRequest::release_col() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSdeleteRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSdeleteRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSdeleteRequest.col)
}

// -------------------------------------------------------------------

// KVRequest_KVSuspendRequest

// optional string target_addr = 1;
inline bool KVRequest_KVSuspendRequest::_internal_has_target_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVSuspendRequest::has_target_addr() const {
  return _internal_has_target_addr();
}
inline void KVRequest_KVSuspendRequest::clear_target_addr() {
  _impl_.target_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVSuspendRequest::target_addr() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVSuspendRequest.target_addr)
  return _internal_target_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVSuspendRequest::set_target_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.target_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVSuspendRequest.target_addr)
}
inline std::string* KVRequest_KVSuspendRequest::mutable_target_addr() {
  std::string* _s = _internal_mutable_target_addr();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVSuspendRequest.target_addr)
  return _s;
}
inline const std::string& KVRequest_KVSuspendRequest::_internal_target_addr() const {
  return _impl_.target_addr_.Get();
}
inline void KVRequest_KVSuspendRequest::_internal_set_target_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVSuspendRequest::_internal_mutable_target_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.target_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVSuspendRequest::release_target_addr() {
  // @@protoc_insertion_point(field_release:KVRequest.KVSuspendRequest.target_addr)
  if (!_internal_has_target_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.target_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_addr_.IsDefault()) {
    _impl_.target_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVSuspendRequest::set_allocated_target_addr(std::string* target_addr) {
  if (target_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_addr_.SetAllocated(target_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_addr_.IsDefault()) {
    _impl_.target_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVSuspendRequest.target_addr)
}

// -------------------------------------------------------------------

// KVRequest_KVRecoveryRequest

// optional string target_addr = 1;
inline bool KVRequest_KVRecoveryRequest::_internal_has_target_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVRecoveryRequest::has_target_addr() const {
  return _internal_has_target_addr();
}
inline void KVRequest_KVRecoveryRequest::clear_target_addr() {
  _impl_.target_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVRecoveryRequest::target_addr() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVRecoveryRequest.target_addr)
  return _internal_target_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVRecoveryRequest::set_target_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.target_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVRecoveryRequest.target_addr)
}
inline std::string* KVRequest_KVRecoveryRequest::mutable_target_addr() {
  std::string* _s = _internal_mutable_target_addr();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVRecoveryRequest.target_addr)
  return _s;
}
inline const std::string& KVRequest_KVRecoveryRequest::_internal_target_addr() const {
  return _impl_.target_addr_.Get();
}
inline void KVRequest_KVRecoveryRequest::_internal_set_target_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVRecoveryRequest::_internal_mutable_target_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.target_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVRecoveryRequest::release_target_addr() {
  // @@protoc_insertion_point(field_release:KVRequest.KVRecoveryRequest.target_addr)
  if (!_internal_has_target_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.target_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_addr_.IsDefault()) {
    _impl_.target_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVRecoveryRequest::set_allocated_target_addr(std::string* target_addr) {
  if (target_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_addr_.SetAllocated(target_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_addr_.IsDefault()) {
    _impl_.target_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVRecoveryRequest.target_addr)
}

// -------------------------------------------------------------------

// KVRequest_KVFiletransferRequest

// optional .FileType file_type = 1;
inline bool KVRequest_KVFiletransferRequest::_internal_has_file_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVFiletransferRequest::has_file_type() const {
  return _internal_has_file_type();
}
inline void KVRequest_KVFiletransferRequest::clear_file_type() {
  _impl_.file_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::FileType KVRequest_KVFiletransferRequest::_internal_file_type() const {
  return static_cast< ::FileType >(_impl_.file_type_);
}
inline ::FileType KVRequest_KVFiletransferRequest::file_type() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVFiletransferRequest.file_type)
  return _internal_file_type();
}
inline void KVRequest_KVFiletransferRequest::_internal_set_file_type(::FileType value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.file_type_ = value;
}
inline void KVRequest_KVFiletransferRequest::set_file_type(::FileType value) {
  _internal_set_file_type(value);
  // @@protoc_insertion_point(field_set:KVRequest.KVFiletransferRequest.file_type)
}

// optional int32 tablet_idx = 2;
inline bool KVRequest_KVFiletransferRequest::_internal_has_tablet_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KVRequest_KVFiletransferRequest::has_tablet_idx() const {
  return _internal_has_tablet_idx();
}
inline void KVRequest_KVFiletransferRequest::clear_tablet_idx() {
  _impl_.tablet_idx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t KVRequest_KVFiletransferRequest::_internal_tablet_idx() const {
  return _impl_.tablet_idx_;
}
inline int32_t KVRequest_KVFiletransferRequest::tablet_idx() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVFiletransferRequest.tablet_idx)
  return _internal_tablet_idx();
}
inline void KVRequest_KVFiletransferRequest::_internal_set_tablet_idx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tablet_idx_ = value;
}
inline void KVRequest_KVFiletransferRequest::set_tablet_idx(int32_t value) {
  _internal_set_tablet_idx(value);
  // @@protoc_insertion_point(field_set:KVRequest.KVFiletransferRequest.tablet_idx)
}

// optional string content = 3;
inline bool KVRequest_KVFiletransferRequest::_internal_has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVFiletransferRequest::has_content() const {
  return _internal_has_content();
}
inline void KVRequest_KVFiletransferRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVFiletransferRequest::content() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVFiletransferRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVFiletransferRequest::set_content(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVFiletransferRequest.content)
}
inline std::string* KVRequest_KVFiletransferRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVFiletransferRequest.content)
  return _s;
}
inline const std::string& KVRequest_KVFiletransferRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void KVRequest_KVFiletransferRequest::_internal_set_content(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVFiletransferRequest::_internal_mutable_content() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVFiletransferRequest::release_content() {
  // @@protoc_insertion_point(field_release:KVRequest.KVFiletransferRequest.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVFiletransferRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVFiletransferRequest.content)
}

// -------------------------------------------------------------------

// KVRequest_KVReplayRequest

// optional int32 tablet_num = 1;
inline bool KVRequest_KVReplayRequest::_internal_has_tablet_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVRequest_KVReplayRequest::has_tablet_num() const {
  return _internal_has_tablet_num();
}
inline void KVRequest_KVReplayRequest::clear_tablet_num() {
  _impl_.tablet_num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t KVRequest_KVReplayRequest::_internal_tablet_num() const {
  return _impl_.tablet_num_;
}
inline int32_t KVRequest_KVReplayRequest::tablet_num() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVReplayRequest.tablet_num)
  return _internal_tablet_num();
}
inline void KVRequest_KVReplayRequest::_internal_set_tablet_num(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tablet_num_ = value;
}
inline void KVRequest_KVReplayRequest::set_tablet_num(int32_t value) {
  _internal_set_tablet_num(value);
  // @@protoc_insertion_point(field_set:KVRequest.KVReplayRequest.tablet_num)
}

// optional string tablet_target = 2;
inline bool KVRequest_KVReplayRequest::_internal_has_tablet_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVRequest_KVReplayRequest::has_tablet_target() const {
  return _internal_has_tablet_target();
}
inline void KVRequest_KVReplayRequest::clear_tablet_target() {
  _impl_.tablet_target_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVRequest_KVReplayRequest::tablet_target() const {
  // @@protoc_insertion_point(field_get:KVRequest.KVReplayRequest.tablet_target)
  return _internal_tablet_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVRequest_KVReplayRequest::set_tablet_target(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tablet_target_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVRequest.KVReplayRequest.tablet_target)
}
inline std::string* KVRequest_KVReplayRequest::mutable_tablet_target() {
  std::string* _s = _internal_mutable_tablet_target();
  // @@protoc_insertion_point(field_mutable:KVRequest.KVReplayRequest.tablet_target)
  return _s;
}
inline const std::string& KVRequest_KVReplayRequest::_internal_tablet_target() const {
  return _impl_.tablet_target_.Get();
}
inline void KVRequest_KVReplayRequest::_internal_set_tablet_target(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tablet_target_.Set(value, GetArenaForAllocation());
}
inline std::string* KVRequest_KVReplayRequest::_internal_mutable_tablet_target() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tablet_target_.Mutable(GetArenaForAllocation());
}
inline std::string* KVRequest_KVReplayRequest::release_tablet_target() {
  // @@protoc_insertion_point(field_release:KVRequest.KVReplayRequest.tablet_target)
  if (!_internal_has_tablet_target()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tablet_target_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablet_target_.IsDefault()) {
    _impl_.tablet_target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVRequest_KVReplayRequest::set_allocated_tablet_target(std::string* tablet_target) {
  if (tablet_target != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tablet_target_.SetAllocated(tablet_target, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablet_target_.IsDefault()) {
    _impl_.tablet_target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVRequest.KVReplayRequest.tablet_target)
}

// -------------------------------------------------------------------

// KVRequest

// .KVRequest.KVGetRequest get_request = 1;
inline bool KVRequest::_internal_has_get_request() const {
  return request_case() == kGetRequest;
}
inline bool KVRequest::has_get_request() const {
  return _internal_has_get_request();
}
inline void KVRequest::set_has_get_request() {
  _impl_._oneof_case_[0] = kGetRequest;
}
inline void KVRequest::clear_get_request() {
  if (_internal_has_get_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.get_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVGetRequest* KVRequest::release_get_request() {
  // @@protoc_insertion_point(field_release:KVRequest.get_request)
  if (_internal_has_get_request()) {
    clear_has_request();
    ::KVRequest_KVGetRequest* temp = _impl_.request_.get_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.get_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVGetRequest& KVRequest::_internal_get_request() const {
  return _internal_has_get_request()
      ? *_impl_.request_.get_request_
      : reinterpret_cast< ::KVRequest_KVGetRequest&>(::_KVRequest_KVGetRequest_default_instance_);
}
inline const ::KVRequest_KVGetRequest& KVRequest::get_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.get_request)
  return _internal_get_request();
}
inline ::KVRequest_KVGetRequest* KVRequest::unsafe_arena_release_get_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.get_request)
  if (_internal_has_get_request()) {
    clear_has_request();
    ::KVRequest_KVGetRequest* temp = _impl_.request_.get_request_;
    _impl_.request_.get_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_get_request(::KVRequest_KVGetRequest* get_request) {
  clear_request();
  if (get_request) {
    set_has_get_request();
    _impl_.request_.get_request_ = get_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.get_request)
}
inline ::KVRequest_KVGetRequest* KVRequest::_internal_mutable_get_request() {
  if (!_internal_has_get_request()) {
    clear_request();
    set_has_get_request();
    _impl_.request_.get_request_ = CreateMaybeMessage< ::KVRequest_KVGetRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.get_request_;
}
inline ::KVRequest_KVGetRequest* KVRequest::mutable_get_request() {
  ::KVRequest_KVGetRequest* _msg = _internal_mutable_get_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.get_request)
  return _msg;
}

// .KVRequest.KVSgetRequest sget_request = 2;
inline bool KVRequest::_internal_has_sget_request() const {
  return request_case() == kSgetRequest;
}
inline bool KVRequest::has_sget_request() const {
  return _internal_has_sget_request();
}
inline void KVRequest::set_has_sget_request() {
  _impl_._oneof_case_[0] = kSgetRequest;
}
inline void KVRequest::clear_sget_request() {
  if (_internal_has_sget_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.sget_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVSgetRequest* KVRequest::release_sget_request() {
  // @@protoc_insertion_point(field_release:KVRequest.sget_request)
  if (_internal_has_sget_request()) {
    clear_has_request();
    ::KVRequest_KVSgetRequest* temp = _impl_.request_.sget_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.sget_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVSgetRequest& KVRequest::_internal_sget_request() const {
  return _internal_has_sget_request()
      ? *_impl_.request_.sget_request_
      : reinterpret_cast< ::KVRequest_KVSgetRequest&>(::_KVRequest_KVSgetRequest_default_instance_);
}
inline const ::KVRequest_KVSgetRequest& KVRequest::sget_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.sget_request)
  return _internal_sget_request();
}
inline ::KVRequest_KVSgetRequest* KVRequest::unsafe_arena_release_sget_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.sget_request)
  if (_internal_has_sget_request()) {
    clear_has_request();
    ::KVRequest_KVSgetRequest* temp = _impl_.request_.sget_request_;
    _impl_.request_.sget_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_sget_request(::KVRequest_KVSgetRequest* sget_request) {
  clear_request();
  if (sget_request) {
    set_has_sget_request();
    _impl_.request_.sget_request_ = sget_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.sget_request)
}
inline ::KVRequest_KVSgetRequest* KVRequest::_internal_mutable_sget_request() {
  if (!_internal_has_sget_request()) {
    clear_request();
    set_has_sget_request();
    _impl_.request_.sget_request_ = CreateMaybeMessage< ::KVRequest_KVSgetRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.sget_request_;
}
inline ::KVRequest_KVSgetRequest* KVRequest::mutable_sget_request() {
  ::KVRequest_KVSgetRequest* _msg = _internal_mutable_sget_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.sget_request)
  return _msg;
}

// .KVRequest.KVPutRequest put_request = 3;
inline bool KVRequest::_internal_has_put_request() const {
  return request_case() == kPutRequest;
}
inline bool KVRequest::has_put_request() const {
  return _internal_has_put_request();
}
inline void KVRequest::set_has_put_request() {
  _impl_._oneof_case_[0] = kPutRequest;
}
inline void KVRequest::clear_put_request() {
  if (_internal_has_put_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.put_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVPutRequest* KVRequest::release_put_request() {
  // @@protoc_insertion_point(field_release:KVRequest.put_request)
  if (_internal_has_put_request()) {
    clear_has_request();
    ::KVRequest_KVPutRequest* temp = _impl_.request_.put_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.put_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVPutRequest& KVRequest::_internal_put_request() const {
  return _internal_has_put_request()
      ? *_impl_.request_.put_request_
      : reinterpret_cast< ::KVRequest_KVPutRequest&>(::_KVRequest_KVPutRequest_default_instance_);
}
inline const ::KVRequest_KVPutRequest& KVRequest::put_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.put_request)
  return _internal_put_request();
}
inline ::KVRequest_KVPutRequest* KVRequest::unsafe_arena_release_put_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.put_request)
  if (_internal_has_put_request()) {
    clear_has_request();
    ::KVRequest_KVPutRequest* temp = _impl_.request_.put_request_;
    _impl_.request_.put_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_put_request(::KVRequest_KVPutRequest* put_request) {
  clear_request();
  if (put_request) {
    set_has_put_request();
    _impl_.request_.put_request_ = put_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.put_request)
}
inline ::KVRequest_KVPutRequest* KVRequest::_internal_mutable_put_request() {
  if (!_internal_has_put_request()) {
    clear_request();
    set_has_put_request();
    _impl_.request_.put_request_ = CreateMaybeMessage< ::KVRequest_KVPutRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.put_request_;
}
inline ::KVRequest_KVPutRequest* KVRequest::mutable_put_request() {
  ::KVRequest_KVPutRequest* _msg = _internal_mutable_put_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.put_request)
  return _msg;
}

// .KVRequest.KVSputRequest sput_request = 4;
inline bool KVRequest::_internal_has_sput_request() const {
  return request_case() == kSputRequest;
}
inline bool KVRequest::has_sput_request() const {
  return _internal_has_sput_request();
}
inline void KVRequest::set_has_sput_request() {
  _impl_._oneof_case_[0] = kSputRequest;
}
inline void KVRequest::clear_sput_request() {
  if (_internal_has_sput_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.sput_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVSputRequest* KVRequest::release_sput_request() {
  // @@protoc_insertion_point(field_release:KVRequest.sput_request)
  if (_internal_has_sput_request()) {
    clear_has_request();
    ::KVRequest_KVSputRequest* temp = _impl_.request_.sput_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.sput_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVSputRequest& KVRequest::_internal_sput_request() const {
  return _internal_has_sput_request()
      ? *_impl_.request_.sput_request_
      : reinterpret_cast< ::KVRequest_KVSputRequest&>(::_KVRequest_KVSputRequest_default_instance_);
}
inline const ::KVRequest_KVSputRequest& KVRequest::sput_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.sput_request)
  return _internal_sput_request();
}
inline ::KVRequest_KVSputRequest* KVRequest::unsafe_arena_release_sput_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.sput_request)
  if (_internal_has_sput_request()) {
    clear_has_request();
    ::KVRequest_KVSputRequest* temp = _impl_.request_.sput_request_;
    _impl_.request_.sput_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_sput_request(::KVRequest_KVSputRequest* sput_request) {
  clear_request();
  if (sput_request) {
    set_has_sput_request();
    _impl_.request_.sput_request_ = sput_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.sput_request)
}
inline ::KVRequest_KVSputRequest* KVRequest::_internal_mutable_sput_request() {
  if (!_internal_has_sput_request()) {
    clear_request();
    set_has_sput_request();
    _impl_.request_.sput_request_ = CreateMaybeMessage< ::KVRequest_KVSputRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.sput_request_;
}
inline ::KVRequest_KVSputRequest* KVRequest::mutable_sput_request() {
  ::KVRequest_KVSputRequest* _msg = _internal_mutable_sput_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.sput_request)
  return _msg;
}

// .KVRequest.KVCPutRequest cput_request = 5;
inline bool KVRequest::_internal_has_cput_request() const {
  return request_case() == kCputRequest;
}
inline bool KVRequest::has_cput_request() const {
  return _internal_has_cput_request();
}
inline void KVRequest::set_has_cput_request() {
  _impl_._oneof_case_[0] = kCputRequest;
}
inline void KVRequest::clear_cput_request() {
  if (_internal_has_cput_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.cput_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVCPutRequest* KVRequest::release_cput_request() {
  // @@protoc_insertion_point(field_release:KVRequest.cput_request)
  if (_internal_has_cput_request()) {
    clear_has_request();
    ::KVRequest_KVCPutRequest* temp = _impl_.request_.cput_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.cput_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVCPutRequest& KVRequest::_internal_cput_request() const {
  return _internal_has_cput_request()
      ? *_impl_.request_.cput_request_
      : reinterpret_cast< ::KVRequest_KVCPutRequest&>(::_KVRequest_KVCPutRequest_default_instance_);
}
inline const ::KVRequest_KVCPutRequest& KVRequest::cput_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.cput_request)
  return _internal_cput_request();
}
inline ::KVRequest_KVCPutRequest* KVRequest::unsafe_arena_release_cput_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.cput_request)
  if (_internal_has_cput_request()) {
    clear_has_request();
    ::KVRequest_KVCPutRequest* temp = _impl_.request_.cput_request_;
    _impl_.request_.cput_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_cput_request(::KVRequest_KVCPutRequest* cput_request) {
  clear_request();
  if (cput_request) {
    set_has_cput_request();
    _impl_.request_.cput_request_ = cput_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.cput_request)
}
inline ::KVRequest_KVCPutRequest* KVRequest::_internal_mutable_cput_request() {
  if (!_internal_has_cput_request()) {
    clear_request();
    set_has_cput_request();
    _impl_.request_.cput_request_ = CreateMaybeMessage< ::KVRequest_KVCPutRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.cput_request_;
}
inline ::KVRequest_KVCPutRequest* KVRequest::mutable_cput_request() {
  ::KVRequest_KVCPutRequest* _msg = _internal_mutable_cput_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.cput_request)
  return _msg;
}

// .KVRequest.KVScputRequest scput_request = 6;
inline bool KVRequest::_internal_has_scput_request() const {
  return request_case() == kScputRequest;
}
inline bool KVRequest::has_scput_request() const {
  return _internal_has_scput_request();
}
inline void KVRequest::set_has_scput_request() {
  _impl_._oneof_case_[0] = kScputRequest;
}
inline void KVRequest::clear_scput_request() {
  if (_internal_has_scput_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.scput_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVScputRequest* KVRequest::release_scput_request() {
  // @@protoc_insertion_point(field_release:KVRequest.scput_request)
  if (_internal_has_scput_request()) {
    clear_has_request();
    ::KVRequest_KVScputRequest* temp = _impl_.request_.scput_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.scput_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVScputRequest& KVRequest::_internal_scput_request() const {
  return _internal_has_scput_request()
      ? *_impl_.request_.scput_request_
      : reinterpret_cast< ::KVRequest_KVScputRequest&>(::_KVRequest_KVScputRequest_default_instance_);
}
inline const ::KVRequest_KVScputRequest& KVRequest::scput_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.scput_request)
  return _internal_scput_request();
}
inline ::KVRequest_KVScputRequest* KVRequest::unsafe_arena_release_scput_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.scput_request)
  if (_internal_has_scput_request()) {
    clear_has_request();
    ::KVRequest_KVScputRequest* temp = _impl_.request_.scput_request_;
    _impl_.request_.scput_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_scput_request(::KVRequest_KVScputRequest* scput_request) {
  clear_request();
  if (scput_request) {
    set_has_scput_request();
    _impl_.request_.scput_request_ = scput_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.scput_request)
}
inline ::KVRequest_KVScputRequest* KVRequest::_internal_mutable_scput_request() {
  if (!_internal_has_scput_request()) {
    clear_request();
    set_has_scput_request();
    _impl_.request_.scput_request_ = CreateMaybeMessage< ::KVRequest_KVScputRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.scput_request_;
}
inline ::KVRequest_KVScputRequest* KVRequest::mutable_scput_request() {
  ::KVRequest_KVScputRequest* _msg = _internal_mutable_scput_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.scput_request)
  return _msg;
}

// .KVRequest.KVDeleteRequest delete_request = 7;
inline bool KVRequest::_internal_has_delete_request() const {
  return request_case() == kDeleteRequest;
}
inline bool KVRequest::has_delete_request() const {
  return _internal_has_delete_request();
}
inline void KVRequest::set_has_delete_request() {
  _impl_._oneof_case_[0] = kDeleteRequest;
}
inline void KVRequest::clear_delete_request() {
  if (_internal_has_delete_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.delete_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVDeleteRequest* KVRequest::release_delete_request() {
  // @@protoc_insertion_point(field_release:KVRequest.delete_request)
  if (_internal_has_delete_request()) {
    clear_has_request();
    ::KVRequest_KVDeleteRequest* temp = _impl_.request_.delete_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.delete_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVDeleteRequest& KVRequest::_internal_delete_request() const {
  return _internal_has_delete_request()
      ? *_impl_.request_.delete_request_
      : reinterpret_cast< ::KVRequest_KVDeleteRequest&>(::_KVRequest_KVDeleteRequest_default_instance_);
}
inline const ::KVRequest_KVDeleteRequest& KVRequest::delete_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.delete_request)
  return _internal_delete_request();
}
inline ::KVRequest_KVDeleteRequest* KVRequest::unsafe_arena_release_delete_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.delete_request)
  if (_internal_has_delete_request()) {
    clear_has_request();
    ::KVRequest_KVDeleteRequest* temp = _impl_.request_.delete_request_;
    _impl_.request_.delete_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_delete_request(::KVRequest_KVDeleteRequest* delete_request) {
  clear_request();
  if (delete_request) {
    set_has_delete_request();
    _impl_.request_.delete_request_ = delete_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.delete_request)
}
inline ::KVRequest_KVDeleteRequest* KVRequest::_internal_mutable_delete_request() {
  if (!_internal_has_delete_request()) {
    clear_request();
    set_has_delete_request();
    _impl_.request_.delete_request_ = CreateMaybeMessage< ::KVRequest_KVDeleteRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.delete_request_;
}
inline ::KVRequest_KVDeleteRequest* KVRequest::mutable_delete_request() {
  ::KVRequest_KVDeleteRequest* _msg = _internal_mutable_delete_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.delete_request)
  return _msg;
}

// .KVRequest.KVSdeleteRequest sdelete_request = 8;
inline bool KVRequest::_internal_has_sdelete_request() const {
  return request_case() == kSdeleteRequest;
}
inline bool KVRequest::has_sdelete_request() const {
  return _internal_has_sdelete_request();
}
inline void KVRequest::set_has_sdelete_request() {
  _impl_._oneof_case_[0] = kSdeleteRequest;
}
inline void KVRequest::clear_sdelete_request() {
  if (_internal_has_sdelete_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.sdelete_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVSdeleteRequest* KVRequest::release_sdelete_request() {
  // @@protoc_insertion_point(field_release:KVRequest.sdelete_request)
  if (_internal_has_sdelete_request()) {
    clear_has_request();
    ::KVRequest_KVSdeleteRequest* temp = _impl_.request_.sdelete_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.sdelete_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVSdeleteRequest& KVRequest::_internal_sdelete_request() const {
  return _internal_has_sdelete_request()
      ? *_impl_.request_.sdelete_request_
      : reinterpret_cast< ::KVRequest_KVSdeleteRequest&>(::_KVRequest_KVSdeleteRequest_default_instance_);
}
inline const ::KVRequest_KVSdeleteRequest& KVRequest::sdelete_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.sdelete_request)
  return _internal_sdelete_request();
}
inline ::KVRequest_KVSdeleteRequest* KVRequest::unsafe_arena_release_sdelete_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.sdelete_request)
  if (_internal_has_sdelete_request()) {
    clear_has_request();
    ::KVRequest_KVSdeleteRequest* temp = _impl_.request_.sdelete_request_;
    _impl_.request_.sdelete_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_sdelete_request(::KVRequest_KVSdeleteRequest* sdelete_request) {
  clear_request();
  if (sdelete_request) {
    set_has_sdelete_request();
    _impl_.request_.sdelete_request_ = sdelete_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.sdelete_request)
}
inline ::KVRequest_KVSdeleteRequest* KVRequest::_internal_mutable_sdelete_request() {
  if (!_internal_has_sdelete_request()) {
    clear_request();
    set_has_sdelete_request();
    _impl_.request_.sdelete_request_ = CreateMaybeMessage< ::KVRequest_KVSdeleteRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.sdelete_request_;
}
inline ::KVRequest_KVSdeleteRequest* KVRequest::mutable_sdelete_request() {
  ::KVRequest_KVSdeleteRequest* _msg = _internal_mutable_sdelete_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.sdelete_request)
  return _msg;
}

// .KVRequest.KVSuspendRequest suspend_request = 9;
inline bool KVRequest::_internal_has_suspend_request() const {
  return request_case() == kSuspendRequest;
}
inline bool KVRequest::has_suspend_request() const {
  return _internal_has_suspend_request();
}
inline void KVRequest::set_has_suspend_request() {
  _impl_._oneof_case_[0] = kSuspendRequest;
}
inline void KVRequest::clear_suspend_request() {
  if (_internal_has_suspend_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.suspend_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVSuspendRequest* KVRequest::release_suspend_request() {
  // @@protoc_insertion_point(field_release:KVRequest.suspend_request)
  if (_internal_has_suspend_request()) {
    clear_has_request();
    ::KVRequest_KVSuspendRequest* temp = _impl_.request_.suspend_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.suspend_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVSuspendRequest& KVRequest::_internal_suspend_request() const {
  return _internal_has_suspend_request()
      ? *_impl_.request_.suspend_request_
      : reinterpret_cast< ::KVRequest_KVSuspendRequest&>(::_KVRequest_KVSuspendRequest_default_instance_);
}
inline const ::KVRequest_KVSuspendRequest& KVRequest::suspend_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.suspend_request)
  return _internal_suspend_request();
}
inline ::KVRequest_KVSuspendRequest* KVRequest::unsafe_arena_release_suspend_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.suspend_request)
  if (_internal_has_suspend_request()) {
    clear_has_request();
    ::KVRequest_KVSuspendRequest* temp = _impl_.request_.suspend_request_;
    _impl_.request_.suspend_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_suspend_request(::KVRequest_KVSuspendRequest* suspend_request) {
  clear_request();
  if (suspend_request) {
    set_has_suspend_request();
    _impl_.request_.suspend_request_ = suspend_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.suspend_request)
}
inline ::KVRequest_KVSuspendRequest* KVRequest::_internal_mutable_suspend_request() {
  if (!_internal_has_suspend_request()) {
    clear_request();
    set_has_suspend_request();
    _impl_.request_.suspend_request_ = CreateMaybeMessage< ::KVRequest_KVSuspendRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.suspend_request_;
}
inline ::KVRequest_KVSuspendRequest* KVRequest::mutable_suspend_request() {
  ::KVRequest_KVSuspendRequest* _msg = _internal_mutable_suspend_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.suspend_request)
  return _msg;
}

// .KVRequest.KVRecoveryRequest recovery_request = 10;
inline bool KVRequest::_internal_has_recovery_request() const {
  return request_case() == kRecoveryRequest;
}
inline bool KVRequest::has_recovery_request() const {
  return _internal_has_recovery_request();
}
inline void KVRequest::set_has_recovery_request() {
  _impl_._oneof_case_[0] = kRecoveryRequest;
}
inline void KVRequest::clear_recovery_request() {
  if (_internal_has_recovery_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.recovery_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVRecoveryRequest* KVRequest::release_recovery_request() {
  // @@protoc_insertion_point(field_release:KVRequest.recovery_request)
  if (_internal_has_recovery_request()) {
    clear_has_request();
    ::KVRequest_KVRecoveryRequest* temp = _impl_.request_.recovery_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.recovery_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVRecoveryRequest& KVRequest::_internal_recovery_request() const {
  return _internal_has_recovery_request()
      ? *_impl_.request_.recovery_request_
      : reinterpret_cast< ::KVRequest_KVRecoveryRequest&>(::_KVRequest_KVRecoveryRequest_default_instance_);
}
inline const ::KVRequest_KVRecoveryRequest& KVRequest::recovery_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.recovery_request)
  return _internal_recovery_request();
}
inline ::KVRequest_KVRecoveryRequest* KVRequest::unsafe_arena_release_recovery_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.recovery_request)
  if (_internal_has_recovery_request()) {
    clear_has_request();
    ::KVRequest_KVRecoveryRequest* temp = _impl_.request_.recovery_request_;
    _impl_.request_.recovery_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_recovery_request(::KVRequest_KVRecoveryRequest* recovery_request) {
  clear_request();
  if (recovery_request) {
    set_has_recovery_request();
    _impl_.request_.recovery_request_ = recovery_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.recovery_request)
}
inline ::KVRequest_KVRecoveryRequest* KVRequest::_internal_mutable_recovery_request() {
  if (!_internal_has_recovery_request()) {
    clear_request();
    set_has_recovery_request();
    _impl_.request_.recovery_request_ = CreateMaybeMessage< ::KVRequest_KVRecoveryRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.recovery_request_;
}
inline ::KVRequest_KVRecoveryRequest* KVRequest::mutable_recovery_request() {
  ::KVRequest_KVRecoveryRequest* _msg = _internal_mutable_recovery_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.recovery_request)
  return _msg;
}

// .KVRequest.KVFiletransferRequest filetransfer_request = 12;
inline bool KVRequest::_internal_has_filetransfer_request() const {
  return request_case() == kFiletransferRequest;
}
inline bool KVRequest::has_filetransfer_request() const {
  return _internal_has_filetransfer_request();
}
inline void KVRequest::set_has_filetransfer_request() {
  _impl_._oneof_case_[0] = kFiletransferRequest;
}
inline void KVRequest::clear_filetransfer_request() {
  if (_internal_has_filetransfer_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.filetransfer_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVFiletransferRequest* KVRequest::release_filetransfer_request() {
  // @@protoc_insertion_point(field_release:KVRequest.filetransfer_request)
  if (_internal_has_filetransfer_request()) {
    clear_has_request();
    ::KVRequest_KVFiletransferRequest* temp = _impl_.request_.filetransfer_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.filetransfer_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVFiletransferRequest& KVRequest::_internal_filetransfer_request() const {
  return _internal_has_filetransfer_request()
      ? *_impl_.request_.filetransfer_request_
      : reinterpret_cast< ::KVRequest_KVFiletransferRequest&>(::_KVRequest_KVFiletransferRequest_default_instance_);
}
inline const ::KVRequest_KVFiletransferRequest& KVRequest::filetransfer_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.filetransfer_request)
  return _internal_filetransfer_request();
}
inline ::KVRequest_KVFiletransferRequest* KVRequest::unsafe_arena_release_filetransfer_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.filetransfer_request)
  if (_internal_has_filetransfer_request()) {
    clear_has_request();
    ::KVRequest_KVFiletransferRequest* temp = _impl_.request_.filetransfer_request_;
    _impl_.request_.filetransfer_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_filetransfer_request(::KVRequest_KVFiletransferRequest* filetransfer_request) {
  clear_request();
  if (filetransfer_request) {
    set_has_filetransfer_request();
    _impl_.request_.filetransfer_request_ = filetransfer_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.filetransfer_request)
}
inline ::KVRequest_KVFiletransferRequest* KVRequest::_internal_mutable_filetransfer_request() {
  if (!_internal_has_filetransfer_request()) {
    clear_request();
    set_has_filetransfer_request();
    _impl_.request_.filetransfer_request_ = CreateMaybeMessage< ::KVRequest_KVFiletransferRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.filetransfer_request_;
}
inline ::KVRequest_KVFiletransferRequest* KVRequest::mutable_filetransfer_request() {
  ::KVRequest_KVFiletransferRequest* _msg = _internal_mutable_filetransfer_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.filetransfer_request)
  return _msg;
}

// .KVRequest.KVReplayRequest replay_request = 13;
inline bool KVRequest::_internal_has_replay_request() const {
  return request_case() == kReplayRequest;
}
inline bool KVRequest::has_replay_request() const {
  return _internal_has_replay_request();
}
inline void KVRequest::set_has_replay_request() {
  _impl_._oneof_case_[0] = kReplayRequest;
}
inline void KVRequest::clear_replay_request() {
  if (_internal_has_replay_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.replay_request_;
    }
    clear_has_request();
  }
}
inline ::KVRequest_KVReplayRequest* KVRequest::release_replay_request() {
  // @@protoc_insertion_point(field_release:KVRequest.replay_request)
  if (_internal_has_replay_request()) {
    clear_has_request();
    ::KVRequest_KVReplayRequest* temp = _impl_.request_.replay_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.replay_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KVRequest_KVReplayRequest& KVRequest::_internal_replay_request() const {
  return _internal_has_replay_request()
      ? *_impl_.request_.replay_request_
      : reinterpret_cast< ::KVRequest_KVReplayRequest&>(::_KVRequest_KVReplayRequest_default_instance_);
}
inline const ::KVRequest_KVReplayRequest& KVRequest::replay_request() const {
  // @@protoc_insertion_point(field_get:KVRequest.replay_request)
  return _internal_replay_request();
}
inline ::KVRequest_KVReplayRequest* KVRequest::unsafe_arena_release_replay_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:KVRequest.replay_request)
  if (_internal_has_replay_request()) {
    clear_has_request();
    ::KVRequest_KVReplayRequest* temp = _impl_.request_.replay_request_;
    _impl_.request_.replay_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVRequest::unsafe_arena_set_allocated_replay_request(::KVRequest_KVReplayRequest* replay_request) {
  clear_request();
  if (replay_request) {
    set_has_replay_request();
    _impl_.request_.replay_request_ = replay_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KVRequest.replay_request)
}
inline ::KVRequest_KVReplayRequest* KVRequest::_internal_mutable_replay_request() {
  if (!_internal_has_replay_request()) {
    clear_request();
    set_has_replay_request();
    _impl_.request_.replay_request_ = CreateMaybeMessage< ::KVRequest_KVReplayRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.replay_request_;
}
inline ::KVRequest_KVReplayRequest* KVRequest::mutable_replay_request() {
  ::KVRequest_KVReplayRequest* _msg = _internal_mutable_replay_request();
  // @@protoc_insertion_point(field_mutable:KVRequest.replay_request)
  return _msg;
}

inline bool KVRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void KVRequest::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline KVRequest::RequestCase KVRequest::request_case() const {
  return KVRequest::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// KVResponse

// optional .KVStatusCode status = 1;
inline bool KVResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KVResponse::has_status() const {
  return _internal_has_status();
}
inline void KVResponse::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::KVStatusCode KVResponse::_internal_status() const {
  return static_cast< ::KVStatusCode >(_impl_.status_);
}
inline ::KVStatusCode KVResponse::status() const {
  // @@protoc_insertion_point(field_get:KVResponse.status)
  return _internal_status();
}
inline void KVResponse::_internal_set_status(::KVStatusCode value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void KVResponse::set_status(::KVStatusCode value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:KVResponse.status)
}

// optional string message = 2;
inline bool KVResponse::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KVResponse::has_message() const {
  return _internal_has_message();
}
inline void KVResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KVResponse::message() const {
  // @@protoc_insertion_point(field_get:KVResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:KVResponse.message)
}
inline std::string* KVResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:KVResponse.message)
  return _s;
}
inline const std::string& KVResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void KVResponse::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* KVResponse::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* KVResponse::release_message() {
  // @@protoc_insertion_point(field_release:KVResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KVResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KVResponse.message)
}

// -------------------------------------------------------------------

// FetchNodeRequest

// optional string row = 1;
inline bool FetchNodeRequest::_internal_has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchNodeRequest::has_row() const {
  return _internal_has_row();
}
inline void FetchNodeRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchNodeRequest::row() const {
  // @@protoc_insertion_point(field_get:FetchNodeRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchNodeRequest::set_row(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FetchNodeRequest.row)
}
inline std::string* FetchNodeRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:FetchNodeRequest.row)
  return _s;
}
inline const std::string& FetchNodeRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void FetchNodeRequest::_internal_set_row(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchNodeRequest::_internal_mutable_row() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchNodeRequest::release_row() {
  // @@protoc_insertion_point(field_release:FetchNodeRequest.row)
  if (!_internal_has_row()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.row_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchNodeRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FetchNodeRequest.row)
}

// optional string col = 2;
inline bool FetchNodeRequest::_internal_has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FetchNodeRequest::has_col() const {
  return _internal_has_col();
}
inline void FetchNodeRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FetchNodeRequest::col() const {
  // @@protoc_insertion_point(field_get:FetchNodeRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchNodeRequest::set_col(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FetchNodeRequest.col)
}
inline std::string* FetchNodeRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:FetchNodeRequest.col)
  return _s;
}
inline const std::string& FetchNodeRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void FetchNodeRequest::_internal_set_col(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchNodeRequest::_internal_mutable_col() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchNodeRequest::release_col() {
  // @@protoc_insertion_point(field_release:FetchNodeRequest.col)
  if (!_internal_has_col()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.col_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchNodeRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FetchNodeRequest.col)
}

// -------------------------------------------------------------------

// FetchNodeResponse

// optional .KVStatusCode status = 1;
inline bool FetchNodeResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FetchNodeResponse::has_status() const {
  return _internal_has_status();
}
inline void FetchNodeResponse::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::KVStatusCode FetchNodeResponse::_internal_status() const {
  return static_cast< ::KVStatusCode >(_impl_.status_);
}
inline ::KVStatusCode FetchNodeResponse::status() const {
  // @@protoc_insertion_point(field_get:FetchNodeResponse.status)
  return _internal_status();
}
inline void FetchNodeResponse::_internal_set_status(::KVStatusCode value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}
inline void FetchNodeResponse::set_status(::KVStatusCode value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:FetchNodeResponse.status)
}

// optional string addr = 2;
inline bool FetchNodeResponse::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchNodeResponse::has_addr() const {
  return _internal_has_addr();
}
inline void FetchNodeResponse::clear_addr() {
  _impl_.addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchNodeResponse::addr() const {
  // @@protoc_insertion_point(field_get:FetchNodeResponse.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchNodeResponse::set_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FetchNodeResponse.addr)
}
inline std::string* FetchNodeResponse::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:FetchNodeResponse.addr)
  return _s;
}
inline const std::string& FetchNodeResponse::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void FetchNodeResponse::_internal_set_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchNodeResponse::_internal_mutable_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchNodeResponse::release_addr() {
  // @@protoc_insertion_point(field_release:FetchNodeResponse.addr)
  if (!_internal_has_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchNodeResponse::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FetchNodeResponse.addr)
}

// optional string error_message = 3;
inline bool FetchNodeResponse::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FetchNodeResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void FetchNodeResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FetchNodeResponse::error_message() const {
  // @@protoc_insertion_point(field_get:FetchNodeResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchNodeResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FetchNodeResponse.error_message)
}
inline std::string* FetchNodeResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:FetchNodeResponse.error_message)
  return _s;
}
inline const std::string& FetchNodeResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void FetchNodeResponse::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchNodeResponse::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchNodeResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:FetchNodeResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchNodeResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FetchNodeResponse.error_message)
}

// -------------------------------------------------------------------

// PollStatusRequest

// -------------------------------------------------------------------

// PollStatusResponse_Cluster_Node

// optional bool is_primary = 1;
inline bool PollStatusResponse_Cluster_Node::_internal_has_is_primary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PollStatusResponse_Cluster_Node::has_is_primary() const {
  return _internal_has_is_primary();
}
inline void PollStatusResponse_Cluster_Node::clear_is_primary() {
  _impl_.is_primary_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool PollStatusResponse_Cluster_Node::_internal_is_primary() const {
  return _impl_.is_primary_;
}
inline bool PollStatusResponse_Cluster_Node::is_primary() const {
  // @@protoc_insertion_point(field_get:PollStatusResponse.Cluster.Node.is_primary)
  return _internal_is_primary();
}
inline void PollStatusResponse_Cluster_Node::_internal_set_is_primary(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_primary_ = value;
}
inline void PollStatusResponse_Cluster_Node::set_is_primary(bool value) {
  _internal_set_is_primary(value);
  // @@protoc_insertion_point(field_set:PollStatusResponse.Cluster.Node.is_primary)
}

// optional string address = 2;
inline bool PollStatusResponse_Cluster_Node::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PollStatusResponse_Cluster_Node::has_address() const {
  return _internal_has_address();
}
inline void PollStatusResponse_Cluster_Node::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PollStatusResponse_Cluster_Node::address() const {
  // @@protoc_insertion_point(field_get:PollStatusResponse.Cluster.Node.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PollStatusResponse_Cluster_Node::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PollStatusResponse.Cluster.Node.address)
}
inline std::string* PollStatusResponse_Cluster_Node::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:PollStatusResponse.Cluster.Node.address)
  return _s;
}
inline const std::string& PollStatusResponse_Cluster_Node::_internal_address() const {
  return _impl_.address_.Get();
}
inline void PollStatusResponse_Cluster_Node::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* PollStatusResponse_Cluster_Node::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* PollStatusResponse_Cluster_Node::release_address() {
  // @@protoc_insertion_point(field_release:PollStatusResponse.Cluster.Node.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PollStatusResponse_Cluster_Node::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PollStatusResponse.Cluster.Node.address)
}

// optional string state = 3;
inline bool PollStatusResponse_Cluster_Node::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PollStatusResponse_Cluster_Node::has_state() const {
  return _internal_has_state();
}
inline void PollStatusResponse_Cluster_Node::clear_state() {
  _impl_.state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PollStatusResponse_Cluster_Node::state() const {
  // @@protoc_insertion_point(field_get:PollStatusResponse.Cluster.Node.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PollStatusResponse_Cluster_Node::set_state(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PollStatusResponse.Cluster.Node.state)
}
inline std::string* PollStatusResponse_Cluster_Node::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:PollStatusResponse.Cluster.Node.state)
  return _s;
}
inline const std::string& PollStatusResponse_Cluster_Node::_internal_state() const {
  return _impl_.state_.Get();
}
inline void PollStatusResponse_Cluster_Node::_internal_set_state(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* PollStatusResponse_Cluster_Node::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* PollStatusResponse_Cluster_Node::release_state() {
  // @@protoc_insertion_point(field_release:PollStatusResponse.Cluster.Node.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.state_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PollStatusResponse_Cluster_Node::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PollStatusResponse.Cluster.Node.state)
}

// -------------------------------------------------------------------

// PollStatusResponse_Cluster

// repeated .PollStatusResponse.Cluster.Node nodes = 1;
inline int PollStatusResponse_Cluster::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int PollStatusResponse_Cluster::nodes_size() const {
  return _internal_nodes_size();
}
inline void PollStatusResponse_Cluster::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::PollStatusResponse_Cluster_Node* PollStatusResponse_Cluster::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:PollStatusResponse.Cluster.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster_Node >*
PollStatusResponse_Cluster::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:PollStatusResponse.Cluster.nodes)
  return &_impl_.nodes_;
}
inline const ::PollStatusResponse_Cluster_Node& PollStatusResponse_Cluster::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::PollStatusResponse_Cluster_Node& PollStatusResponse_Cluster::nodes(int index) const {
  // @@protoc_insertion_point(field_get:PollStatusResponse.Cluster.nodes)
  return _internal_nodes(index);
}
inline ::PollStatusResponse_Cluster_Node* PollStatusResponse_Cluster::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::PollStatusResponse_Cluster_Node* PollStatusResponse_Cluster::add_nodes() {
  ::PollStatusResponse_Cluster_Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:PollStatusResponse.Cluster.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster_Node >&
PollStatusResponse_Cluster::nodes() const {
  // @@protoc_insertion_point(field_list:PollStatusResponse.Cluster.nodes)
  return _impl_.nodes_;
}

// -------------------------------------------------------------------

// PollStatusResponse

// repeated .PollStatusResponse.Cluster clusters = 1;
inline int PollStatusResponse::_internal_clusters_size() const {
  return _impl_.clusters_.size();
}
inline int PollStatusResponse::clusters_size() const {
  return _internal_clusters_size();
}
inline void PollStatusResponse::clear_clusters() {
  _impl_.clusters_.Clear();
}
inline ::PollStatusResponse_Cluster* PollStatusResponse::mutable_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:PollStatusResponse.clusters)
  return _impl_.clusters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster >*
PollStatusResponse::mutable_clusters() {
  // @@protoc_insertion_point(field_mutable_list:PollStatusResponse.clusters)
  return &_impl_.clusters_;
}
inline const ::PollStatusResponse_Cluster& PollStatusResponse::_internal_clusters(int index) const {
  return _impl_.clusters_.Get(index);
}
inline const ::PollStatusResponse_Cluster& PollStatusResponse::clusters(int index) const {
  // @@protoc_insertion_point(field_get:PollStatusResponse.clusters)
  return _internal_clusters(index);
}
inline ::PollStatusResponse_Cluster* PollStatusResponse::_internal_add_clusters() {
  return _impl_.clusters_.Add();
}
inline ::PollStatusResponse_Cluster* PollStatusResponse::add_clusters() {
  ::PollStatusResponse_Cluster* _add = _internal_add_clusters();
  // @@protoc_insertion_point(field_add:PollStatusResponse.clusters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PollStatusResponse_Cluster >&
PollStatusResponse::clusters() const {
  // @@protoc_insertion_point(field_list:PollStatusResponse.clusters)
  return _impl_.clusters_;
}

// -------------------------------------------------------------------

// SuspendRequest

// optional int32 cluster_id = 1;
inline bool SuspendRequest::_internal_has_cluster_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SuspendRequest::has_cluster_id() const {
  return _internal_has_cluster_id();
}
inline void SuspendRequest::clear_cluster_id() {
  _impl_.cluster_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SuspendRequest::_internal_cluster_id() const {
  return _impl_.cluster_id_;
}
inline int32_t SuspendRequest::cluster_id() const {
  // @@protoc_insertion_point(field_get:SuspendRequest.cluster_id)
  return _internal_cluster_id();
}
inline void SuspendRequest::_internal_set_cluster_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cluster_id_ = value;
}
inline void SuspendRequest::set_cluster_id(int32_t value) {
  _internal_set_cluster_id(value);
  // @@protoc_insertion_point(field_set:SuspendRequest.cluster_id)
}

// optional string node_addr = 2;
inline bool SuspendRequest::_internal_has_node_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SuspendRequest::has_node_addr() const {
  return _internal_has_node_addr();
}
inline void SuspendRequest::clear_node_addr() {
  _impl_.node_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SuspendRequest::node_addr() const {
  // @@protoc_insertion_point(field_get:SuspendRequest.node_addr)
  return _internal_node_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SuspendRequest::set_node_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.node_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SuspendRequest.node_addr)
}
inline std::string* SuspendRequest::mutable_node_addr() {
  std::string* _s = _internal_mutable_node_addr();
  // @@protoc_insertion_point(field_mutable:SuspendRequest.node_addr)
  return _s;
}
inline const std::string& SuspendRequest::_internal_node_addr() const {
  return _impl_.node_addr_.Get();
}
inline void SuspendRequest::_internal_set_node_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* SuspendRequest::_internal_mutable_node_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* SuspendRequest::release_node_addr() {
  // @@protoc_insertion_point(field_release:SuspendRequest.node_addr)
  if (!_internal_has_node_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.node_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_addr_.IsDefault()) {
    _impl_.node_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SuspendRequest::set_allocated_node_addr(std::string* node_addr) {
  if (node_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_addr_.SetAllocated(node_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_addr_.IsDefault()) {
    _impl_.node_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SuspendRequest.node_addr)
}

// -------------------------------------------------------------------

// ReviveRequest

// optional int32 cluster_id = 1;
inline bool ReviveRequest::_internal_has_cluster_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReviveRequest::has_cluster_id() const {
  return _internal_has_cluster_id();
}
inline void ReviveRequest::clear_cluster_id() {
  _impl_.cluster_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ReviveRequest::_internal_cluster_id() const {
  return _impl_.cluster_id_;
}
inline int32_t ReviveRequest::cluster_id() const {
  // @@protoc_insertion_point(field_get:ReviveRequest.cluster_id)
  return _internal_cluster_id();
}
inline void ReviveRequest::_internal_set_cluster_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cluster_id_ = value;
}
inline void ReviveRequest::set_cluster_id(int32_t value) {
  _internal_set_cluster_id(value);
  // @@protoc_insertion_point(field_set:ReviveRequest.cluster_id)
}

// optional string node_addr = 2;
inline bool ReviveRequest::_internal_has_node_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReviveRequest::has_node_addr() const {
  return _internal_has_node_addr();
}
inline void ReviveRequest::clear_node_addr() {
  _impl_.node_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReviveRequest::node_addr() const {
  // @@protoc_insertion_point(field_get:ReviveRequest.node_addr)
  return _internal_node_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReviveRequest::set_node_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.node_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReviveRequest.node_addr)
}
inline std::string* ReviveRequest::mutable_node_addr() {
  std::string* _s = _internal_mutable_node_addr();
  // @@protoc_insertion_point(field_mutable:ReviveRequest.node_addr)
  return _s;
}
inline const std::string& ReviveRequest::_internal_node_addr() const {
  return _impl_.node_addr_.Get();
}
inline void ReviveRequest::_internal_set_node_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.node_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* ReviveRequest::_internal_mutable_node_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.node_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* ReviveRequest::release_node_addr() {
  // @@protoc_insertion_point(field_release:ReviveRequest.node_addr)
  if (!_internal_has_node_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.node_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_addr_.IsDefault()) {
    _impl_.node_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReviveRequest::set_allocated_node_addr(std::string* node_addr) {
  if (node_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_addr_.SetAllocated(node_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_addr_.IsDefault()) {
    _impl_.node_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReviveRequest.node_addr)
}

// -------------------------------------------------------------------

// NotifyRecoveryFinishedRequest

// optional string target_addr = 1;
inline bool NotifyRecoveryFinishedRequest::_internal_has_target_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NotifyRecoveryFinishedRequest::has_target_addr() const {
  return _internal_has_target_addr();
}
inline void NotifyRecoveryFinishedRequest::clear_target_addr() {
  _impl_.target_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyRecoveryFinishedRequest::target_addr() const {
  // @@protoc_insertion_point(field_get:NotifyRecoveryFinishedRequest.target_addr)
  return _internal_target_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NotifyRecoveryFinishedRequest::set_target_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.target_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NotifyRecoveryFinishedRequest.target_addr)
}
inline std::string* NotifyRecoveryFinishedRequest::mutable_target_addr() {
  std::string* _s = _internal_mutable_target_addr();
  // @@protoc_insertion_point(field_mutable:NotifyRecoveryFinishedRequest.target_addr)
  return _s;
}
inline const std::string& NotifyRecoveryFinishedRequest::_internal_target_addr() const {
  return _impl_.target_addr_.Get();
}
inline void NotifyRecoveryFinishedRequest::_internal_set_target_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* NotifyRecoveryFinishedRequest::_internal_mutable_target_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.target_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* NotifyRecoveryFinishedRequest::release_target_addr() {
  // @@protoc_insertion_point(field_release:NotifyRecoveryFinishedRequest.target_addr)
  if (!_internal_has_target_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.target_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_addr_.IsDefault()) {
    _impl_.target_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NotifyRecoveryFinishedRequest::set_allocated_target_addr(std::string* target_addr) {
  if (target_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_addr_.SetAllocated(target_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_addr_.IsDefault()) {
    _impl_.target_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NotifyRecoveryFinishedRequest.target_addr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::KVStatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KVStatusCode>() {
  return ::KVStatusCode_descriptor();
}
template <> struct is_proto_enum< ::FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileType>() {
  return ::FileType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kvstore_2eproto
